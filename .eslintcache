[{"/Users/jinmingliu/work/ccc-react-paint/src/index.tsx":"1","/Users/jinmingliu/code/ccc-react-paint/src/index.tsx":"2","/Users/jinmingliu/code/ccc-react-paint/src/CCCPaint.tsx":"3","/Users/jinmingliu/code/ccc-react-paint/src/util/toolType.ts":"4","/Users/jinmingliu/code/ccc-react-paint/src/utils.tsx":"5","/Users/jinmingliu/code/ccc-react-paint/src/context/index.ts":"6","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/index.ts":"7","/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/index.ts":"8","/Users/jinmingliu/code/ccc-react-paint/src/canvas/index.tsx":"9","/Users/jinmingliu/code/ccc-react-paint/src/left-tool/index.tsx":"10","/Users/jinmingliu/code/ccc-react-paint/src/right/index.tsx":"11","/Users/jinmingliu/code/ccc-react-paint/src/edit/index.tsx":"12","/Users/jinmingliu/code/ccc-react-paint/src/components/loading/index.tsx":"13","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/tool.ts":"14","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/eraser.ts":"15","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorExtract.ts":"16","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorFill.ts":"17","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/pen.ts":"18","/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/event.ts":"19","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/shape.ts":"20","/Users/jinmingliu/code/ccc-react-paint/src/ToolTypeIcon.tsx":"21","/Users/jinmingliu/code/ccc-react-paint/src/util/snapshot/index.ts":"22","/Users/jinmingliu/code/ccc-react-paint/src/right/pen/index.tsx":"23","/Users/jinmingliu/code/ccc-react-paint/src/right/showShape/index.tsx":"24","/Users/jinmingliu/code/ccc-react-paint/src/right/formatColor/index.tsx":"25","/Users/jinmingliu/code/ccc-react-paint/src/right/text/index.tsx":"26","/Users/jinmingliu/code/ccc-react-paint/src/right/earser/index.tsx":"27","/Users/jinmingliu/code/ccc-react-paint/src/right/components/colorPanel/index.tsx":"28","/Users/jinmingliu/code/ccc-react-paint/src/right/components/slider/index.tsx":"29","/Users/jinmingliu/code/ccc-react-paint/src/right/components/shape/index.tsx":"30","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/Text.ts":"31","/Users/jinmingliu/code/ccc-react-paint/src/util/colorChange.ts":"32","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorChange.ts":"33"},{"size":161,"mtime":1655091758625,"results":"34","hashOfConfig":"35"},{"size":161,"mtime":1657536349590,"results":"36","hashOfConfig":"37"},{"size":8396,"mtime":1658114899070,"results":"38","hashOfConfig":"37"},{"size":918,"mtime":1657536349596,"results":"39","hashOfConfig":"37"},{"size":2069,"mtime":1657536389590,"results":"40","hashOfConfig":"37"},{"size":1493,"mtime":1657851440095,"results":"41","hashOfConfig":"37"},{"size":283,"mtime":1657785817425,"results":"42","hashOfConfig":"37"},{"size":2010,"mtime":1657536349594,"results":"43","hashOfConfig":"37"},{"size":16320,"mtime":1657875303337,"results":"44","hashOfConfig":"37"},{"size":3164,"mtime":1657536389585,"results":"45","hashOfConfig":"37"},{"size":1368,"mtime":1657870424040,"results":"46","hashOfConfig":"37"},{"size":1629,"mtime":1657536389585,"results":"47","hashOfConfig":"37"},{"size":363,"mtime":1657854653271,"results":"48","hashOfConfig":"37"},{"size":4386,"mtime":1657795254133,"results":"49","hashOfConfig":"37"},{"size":2904,"mtime":1657789065498,"results":"50","hashOfConfig":"37"},{"size":1045,"mtime":1657536389588,"results":"51","hashOfConfig":"37"},{"size":4506,"mtime":1657784616619,"results":"52","hashOfConfig":"37"},{"size":3306,"mtime":1657784810620,"results":"53","hashOfConfig":"37"},{"size":136,"mtime":1657536349594,"results":"54","hashOfConfig":"37"},{"size":8338,"mtime":1657786077495,"results":"55","hashOfConfig":"37"},{"size":13540,"mtime":1657536389583,"results":"56","hashOfConfig":"37"},{"size":988,"mtime":1657536389587,"results":"57","hashOfConfig":"37"},{"size":906,"mtime":1657786175794,"results":"58","hashOfConfig":"37"},{"size":1172,"mtime":1657876886830,"results":"59","hashOfConfig":"37"},{"size":720,"mtime":1658116303796,"results":"60","hashOfConfig":"37"},{"size":3960,"mtime":1658116464418,"results":"61","hashOfConfig":"37"},{"size":763,"mtime":1657870516518,"results":"62","hashOfConfig":"37"},{"size":3140,"mtime":1657861495989,"results":"63","hashOfConfig":"37"},{"size":961,"mtime":1657876951287,"results":"64","hashOfConfig":"37"},{"size":4046,"mtime":1658112783888,"results":"65","hashOfConfig":"37"},{"size":10471,"mtime":1658115064126,"results":"66","hashOfConfig":"37"},{"size":3956,"mtime":1657765328572,"results":"67","hashOfConfig":"37"},{"size":4190,"mtime":1657871108410,"results":"68","hashOfConfig":"37"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"71"},"bh4dz0",{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},"7p77ne",{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"79","messages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"81","messages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"83","messages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"85","messages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"89","usedDeprecatedRules":"74"},{"filePath":"90","messages":"91","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"92","messages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"94","messages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"96","messages":"97","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"98","messages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"100","usedDeprecatedRules":"74"},{"filePath":"101","messages":"102","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"103","usedDeprecatedRules":"74"},{"filePath":"104","messages":"105","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"106","messages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"74"},{"filePath":"109","messages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111","usedDeprecatedRules":"74"},{"filePath":"112","messages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"114","messages":"115","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"74"},{"filePath":"117","messages":"118","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"119","messages":"120","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"121","messages":"122","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"123","usedDeprecatedRules":"74"},{"filePath":"124","messages":"125","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"126","usedDeprecatedRules":"74"},{"filePath":"127","messages":"128","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"129","messages":"130","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"131","messages":"132","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"133","usedDeprecatedRules":"74"},{"filePath":"134","messages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"136","usedDeprecatedRules":"74"},{"filePath":"137","messages":"138","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"139","messages":"140","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"141","messages":"142","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"143","messages":"144","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"145","messages":"146","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},"/Users/jinmingliu/work/ccc-react-paint/src/index.tsx",[],[],"/Users/jinmingliu/code/ccc-react-paint/src/index.tsx",[],[],"/Users/jinmingliu/code/ccc-react-paint/src/CCCPaint.tsx",["147"],"/Users/jinmingliu/code/ccc-react-paint/src/util/toolType.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/utils.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/context/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/canvas/index.tsx",["148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164"],"import React, { useMemo } from \"react\";\nimport \"./index.less\";\nimport { useEffect } from \"react\";\nimport { useRef } from \"react\";\nimport { Input } from \"antd\";\n\nimport {\n  LineWidthType,\n  ShapeOutlineType,\n  ShapeToolType,\n  ToolType,\n} from \"../util/toolType\";\nimport { FC } from \"react\";\nimport { useState } from \"react\";\nimport { Pen, Tool, Eraser, ColorFill, Text } from \"../util/tool\";\nimport Shape from \"../util/tool/shape\";\nimport { useContext } from \"react\";\nimport { DispatcherContext } from \"../context\";\nimport { CLEAR_EVENT, REDO_EVENT, UNDO_EVENT } from \"../util/dispatcher/event\";\nimport SnapShot from \"../util/snapshot\";\nimport cursorPen from \"@/assets/icon/cursorPen.jpg\";\nimport cursorErase from \"@/assets/icon/cursorErase.jpg\";\nimport straw from \"@/assets/icon/straw.jpg\";\nimport bucket from \"@/assets/icon/bucket.jpg\";\nconst { TextArea } = Input;\n\ninterface CanvasProps {\n  toolType: ToolType;\n  shapeType: ShapeToolType;\n  shapeOutlineType: ShapeOutlineType;\n  lineWidthType: LineWidthType;\n  strawType: boolean;\n  mainColor: string;\n  subColor: string;\n  lineSize?: number;\n  fillColor: string;\n  fontStyle: any;\n  imgSrc?: string;\n  CanvasSize?: {\n    width: number;\n    height: number;\n  };\n  id: string;\n  background?: string;\n  onSize?: (value: any) => void;\n  setColor: (value: string) => void;\n}\n\nlet show_scale = 1;\n\nlet translatex = 0;\nlet translatey = 0;\n\nconst maxScale = 6;\nconst minScale = 0.1;\nconst scaleStep = 0.1;\n\nconst Canvas: FC<CanvasProps> = (props) => {\n  const {\n    id,\n    toolType,\n    lineWidthType,\n    mainColor,\n    subColor,\n    setColor,\n    CanvasSize,\n    fillColor,\n    shapeType,\n    shapeOutlineType,\n    fontStyle,\n    imgSrc,\n    background,\n    strawType,\n    lineSize = 1,\n  } = props;\n  const [tool, setTool] = useState<Tool>();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const allCanvasRef = useRef<HTMLDivElement>(null);\n  const canvasTextRef = useRef<HTMLDivElement>(null);\n  const textBoxRef = useRef<HTMLTextAreaElement>(null);\n  const dispatcherContext = useContext(DispatcherContext);\n  const [snapshot] = useState<SnapShot>(new SnapShot());\n  const [text, setText] = useState(\"\");\n\n  useEffect(() => {\n    showCanvasCursor();\n    switch (toolType) {\n      case ToolType.PEN:\n        setTool(new Pen());\n        break;\n      case ToolType.ERASER:\n        setTool(new Eraser(lineSize));\n        break;\n      // case ToolType.COLOR_EXTRACT:\n      //   setTool(new ColorExtract(setColor));\n      //   break;\n      case ToolType.COLOR_FILL:\n        setTool(new ColorFill());\n        break;\n      case ToolType.TEXT:\n        setTool(new Text(fontStyle));\n        break;\n      case ToolType.SHAPE:\n        setTool(\n          new Shape(shapeType, shapeOutlineType === ShapeOutlineType.DOTTED)\n        );\n        break;\n      default:\n        break;\n    }\n  }, [toolType, shapeType, fontStyle, lineSize]);\n\n  useEffect(() => {\n    if (tool instanceof Shape) {\n      tool.isDashed = shapeOutlineType === ShapeOutlineType.DOTTED;\n    }\n  }, [shapeOutlineType]);\n\n  useEffect(() => {\n    switch (lineWidthType) {\n      case LineWidthType.THIN:\n        Tool.lineWidthFactor = 1;\n        break;\n      case LineWidthType.MIDDLE:\n        Tool.lineWidthFactor = 2;\n        break;\n      case LineWidthType.BOLD:\n        Tool.lineWidthFactor = 3;\n        break;\n      case LineWidthType.MAXBOLD:\n        Tool.lineWidthFactor = 4;\n        break;\n      case LineWidthType.LINESIZE:\n        Tool.lineWidthFactor = lineSize;\n        break;\n      default:\n        break;\n    }\n  }, [lineWidthType, lineSize]);\n\n  useEffect(() => {\n    Tool.mainColor = mainColor;\n  }, [mainColor]);\n\n  useEffect(() => {\n    Tool.fillColor = fillColor;\n  }, [fillColor]);\n\n  useEffect(() => {\n    Tool.subColor = subColor;\n  }, [subColor]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      showCanvasCursor();\n      // drawCanvas();\n      Tool.ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n      // 注册清空画布事件\n      const dispatcher = dispatcherContext.dispatcher;\n      const callback = () => {\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n          if (imgSrc) {\n            const img = new Image();\n            img.crossOrigin = \"anonymous\";\n            img.src = imgSrc;\n            img.onload = function () {\n              const { width, height } = img;\n              /*1.在canvas 中绘制图像*/\n              ctx.drawImage(img, 0, 0);\n              /*2.从canvas 中获取图像的ImageData*/\n              const imgData = ctx.getImageData(0, 0, width, height);\n              /*3.在canvas 中显示ImageData*/\n              ctx.putImageData(\n                imgData,\n                //位置\n                0,\n                height\n              );\n              snapshot.add(imgData);\n            };\n          } else {\n            ctx.fillStyle = \"#2d2d2d\";\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n          }\n        }\n      };\n      dispatcher.on(CLEAR_EVENT, callback);\n\n      // 注册画布前进事件\n      const forward = () => {\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n          const imageData = snapshot.forward();\n          if (imageData) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.putImageData(imageData, 0, 0);\n          }\n        }\n      };\n      dispatcher.on(REDO_EVENT, forward);\n\n      // 注册画布后退事件\n      const back = () => {\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n          const imageData = snapshot.back();\n          if (imageData) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.putImageData(imageData, 0, 0);\n          }\n        }\n      };\n      dispatcher.on(UNDO_EVENT, back);\n\n      return () => {\n        dispatcher.off(CLEAR_EVENT, callback);\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(() => {\n    showCanvasCursor();\n  }, [strawType]);\n\n  //鼠标icon\n  const showCanvasCursor = () => {\n    const canvas = canvasRef.current;\n    const textBox: any = textBoxRef.current;\n    const showText = textBox?.resizableTextArea?.textArea;\n    if (text) {\n      setText(\"\");\n    }\n    if (canvas) {\n      if (strawType) {\n        //吸色\n        return (canvas.style.cursor = `url(${straw}) 12 16,auto`);\n      }\n      if (toolType === 0) {\n        canvas.style.cursor = `url(${cursorPen}) 12 16,auto`;\n      } else if (toolType === 4) {\n        canvas.style.cursor = `url(${cursorErase}) 12 16,auto`;\n      } else if (toolType === 1) {\n        canvas.style.cursor = `url(${bucket}) 12 16,auto`;\n      } else {\n        canvas.style.cursor = `auto`;\n      }\n      if (toolType !== 2 && textBox && showText) {\n        showText!.setAttribute(\"style\", `z-index:-1;display:none`);\n      }\n    }\n  };\n\n  const drawCanvas = () => {\n    const canvas = canvasRef.current;\n    const container = allCanvasRef!.current;\n    const textRef = canvasTextRef.current;\n    if (canvas && container && textRef) {\n      const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n      if (imgSrc) {\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.src = imgSrc;\n        img.onload = function () {\n          canvas.height = img.height;\n          canvas.width = img.width;\n          /*1.在canvas 中绘制图像*/\n          // ctx.scale(showScale, showScale);\n          textRef.setAttribute(\n            \"style\",\n            `width:${canvas.width};height:${canvas.height}`\n          );\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n          snapshot.add(ctx.getImageData(0, 0, canvas.width, canvas.height));\n        };\n      } else if (CanvasSize) {\n        canvas.height = CanvasSize.height;\n        canvas.width = CanvasSize.width;\n        ctx.fillStyle = background || \"#2d2d2d\";\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        snapshot.add(ctx.getImageData(0, 0, canvas.width, canvas.height));\n      }\n    }\n  };\n\n  useEffect(() => {\n    const container = allCanvasRef!.current;\n    const canvas = canvasRef.current;\n\n    if (CanvasSize && container && canvas) {\n      if (Tool.ctx) {\n        Tool.ctx.clearRect(0, 0, canvas.width, canvas?.height);\n      }\n      drawCanvas();\n      const height = container!.clientHeight;\n      const width = container!.clientWidth;\n      const showScale =\n        Math.min(width, height) /\n          Math.max(CanvasSize.height, CanvasSize.width) || 1;\n      show_scale = showScale; //getScale({ width, height }, CanvasSize);\n      Tool.currentScale = show_scale;\n      translatex = (width - CanvasSize.width * show_scale) / 2 / show_scale;\n      translatey = (height - CanvasSize.height * show_scale) / 2;\n      Tool.translate = {\n        translatex,\n        translatey,\n      };\n      canvas.style.transform = `scale(${show_scale}) translate(${translatex}px,${translatey}px)`;\n      //canvas.style.transform = `translate(${translatex}px,${translatey}px)`;\n    }\n  }, [CanvasSize]);\n\n  const onMouseDown = (event: MouseEvent) => {\n    // if (text) {\n    //   setText(\"\");\n    // }\n    if (tool) {\n      tool.onMouseDown(event);\n    }\n  };\n\n  const onMouseUp = (event: MouseEvent) => {\n    if (text) {\n      setText(\"\");\n    }\n    if (tool) {\n      tool.onMouseUp(event);\n      // 存储canvas剪影\n      snapshot.add(\n        Tool.ctx.getImageData(\n          0,\n          0,\n          Tool.ctx.canvas.width,\n          Tool.ctx.canvas.height\n        )\n      );\n    }\n  };\n\n  const onTouchStart = (event: TouchEvent) => {\n    if (tool) {\n      tool.onTouchStart(event);\n    }\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    if (tool) {\n      tool.onTouchMove(event);\n    }\n  };\n\n  const onTouchEnd = (event: TouchEvent) => {\n    if (tool) {\n      tool.onTouchEnd(event);\n    }\n    // 存储canvas剪影\n    snapshot.add(\n      Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height)\n    );\n  };\n\n  const getTrans = (\n    client: number,\n    newScale: number,\n    direction: string,\n    img: any,\n    boxdom: any,\n    scale: number\n  ) => {\n    const lastTrans = direction === \"width\" ? translatex : translatey;\n    // console.log(\"已经偏移的距离:\", lastTrans);\n\n    const sizeChanage = img[direction] * newScale - img[direction] * scale;\n    // console.log(`img ${direction}放大了:`, sizeChanage);\n\n    // 整体已经移动过了，需要弥补回来\n    const pre = client - lastTrans - boxdom[direction === \"width\" ? \"x\" : \"y\"];\n\n    //console.log(\"缩放中心到边界的距离\", pre);\n\n    const percent = pre / (img[direction] * scale);\n\n    //  console.log(\"当前缩放尺度下，缩放中心到边界比例\", percent);\n\n    const trans = percent * sizeChanage;\n    // console.log(\"缩放中心移动的距离:\", trans);\n    return trans;\n  };\n\n  const onMousewheel = (event: WheelEvent) => {\n    event.preventDefault();\n    if (toolType === ToolType.TEXT) {\n      return;\n    }\n    const canvas = canvasRef.current;\n    const container = allCanvasRef!.current;\n    const { clientX, clientY, deltaX, deltaY, ctrlKey } = event;\n    const { width, height, x, y } = container!.getBoundingClientRect();\n    const { width: canvasWidth, height: canvasHeight } =\n      container!.getBoundingClientRect();\n    let newScale;\n    if (ctrlKey) {\n      //双指放大缩小\n      if (deltaY < 0) {\n        newScale = show_scale + scaleStep;\n        newScale = Math.min(newScale, maxScale);\n      } else {\n        newScale = show_scale - scaleStep;\n        newScale = Math.max(newScale, minScale);\n      }\n      const transX = getTrans(\n        clientX,\n        newScale,\n        \"width\",\n        CanvasSize,\n        {\n          width,\n          height,\n          x,\n          y,\n        },\n        show_scale\n      );\n      const transY = getTrans(\n        clientY,\n        newScale,\n        \"height\",\n        CanvasSize,\n        {\n          width,\n          height,\n          x,\n          y,\n        },\n        show_scale\n      );\n      translatex = translatex - transX;\n      translatey = translatey - transY;\n      show_scale = newScale;\n      Tool.currentScale = newScale;\n      Tool.translate = {\n        translatex,\n        translatey,\n      };\n      canvas!.style.transform = `translate3d(${translatex}px, ${translatey}px, 0px) scale(${show_scale})`;\n    }\n    // else {\n    //   if (!!deltaX && !deltaY) {\n    //     // if (translatex > 0 && translatex < width) {\n    //     // 左右移动 向右 -deltaX < 0  向左   >0\n    //     translatex = Number((translatex - deltaX).toFixed(3));\n    //     // }\n    //   } else if (!!deltaY && !deltaX) {\n    //     // if (translatey > 0 && translatex < height) {\n    //     // 左右移动 向右 -deltaX < 0  向左   >0\n    //     translatey = Number((translatey - deltaY).toFixed(3));\n    //     // }\n    //   }\n    // }\n  };\n\n  const onCanvasBoxWheel = (event: WheelEvent) => {\n    const { clientX, clientY, deltaX, deltaY, ctrlKey } = event;\n    event.preventDefault();\n    if (toolType === ToolType.TEXT) {\n      return;\n    }\n    const canvas = canvasRef.current;\n    if (!ctrlKey) {\n      if (!!deltaX && !deltaY) {\n        // if (translatex > 0 && translatex < width) {\n        // 左右移动 向右 -deltaX < 0  向左   >0\n        translatex = Number((translatex - deltaX).toFixed(3));\n        // }\n      } else if (!!deltaY && !deltaX) {\n        // if (translatey > 0 && translatex < height) {\n        // 左右移动 向右 -deltaX < 0  向左   >0\n        translatey = Number((translatey - deltaY).toFixed(3));\n        // }\n      }\n      Tool.translate = {\n        translatex,\n        translatey,\n      };\n      canvas!.style.transform = `translate(${translatex}px, ${translatey}px) scale(${show_scale})`;\n    }\n  };\n\n  const onKeyDown = (e: KeyboardEvent) => {\n    if (tool) {\n      tool.onKeyDown(e);\n    }\n  };\n\n  const onMouseMove = (event: MouseEvent) => {\n    if (tool) {\n      tool.onMouseMove(event);\n    }\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    // const textBox = textBoxRef.current;\n    const canvasBox = allCanvasRef.current;\n    if (canvas && canvasBox) {\n      canvas.addEventListener(\"mousedown\", onMouseDown);\n      canvas.addEventListener(\"mousemove\", onMouseMove);\n      canvas.addEventListener(\"mouseup\", onMouseUp);\n      canvas.addEventListener(\"wheel\", onMousewheel, { passive: false });\n      canvas.addEventListener(\"touchstart\", onTouchStart);\n      canvas.addEventListener(\"touchmove\", onTouchMove);\n      canvas.addEventListener(\"touchend\", onTouchEnd);\n      window.addEventListener(\"keydown\", onKeyDown);\n      // textBox.addEventListener(\"keydown\", onKeyDown);\n      canvasBox.addEventListener(\"wheel\", onCanvasBoxWheel, { passive: false });\n\n      return () => {\n        canvas.removeEventListener(\"mousedown\", onMouseDown);\n        canvas.removeEventListener(\"mousemove\", onMouseMove);\n        canvas.removeEventListener(\"mouseup\", onMouseUp);\n        canvas.removeEventListener(\"wheel\", onMousewheel);\n\n        canvas.removeEventListener(\"touchstart\", onTouchStart);\n        canvas.removeEventListener(\"touchmove\", onTouchMove);\n        canvas.removeEventListener(\"touchend\", onTouchEnd);\n        // textBox.removeEventListener(\"keydown\", onKeyDown);\n\n        canvasBox.removeEventListener(\"wheel\", onCanvasBoxWheel);\n      };\n    }\n  }, [canvasRef, onMouseDown, onMouseMove, onMouseUp]);\n\n  const style = {\n    margin: \"auto\",\n  };\n  if (allCanvasRef && CanvasSize) {\n    const allCanvas = allCanvasRef.current;\n    if (allCanvas) {\n      style.margin =\n        allCanvas.offsetWidth < (CanvasSize?.width || 0) ? \"unset\" : \"auto\";\n    }\n  }\n  return (\n    <div className=\"all-canvas\" ref={allCanvasRef} id=\"all-canvas\">\n      <canvas\n        id={`ccc-paint-canvas ${id}`}\n        className=\"ccc-paint-canvas\"\n        ref={canvasRef}\n        style={{\n          background: background,\n          ...style,\n        }}\n      ></canvas>\n      <div className=\"canvas-text\" id=\"text-container\" ref={canvasTextRef}>\n        <TextArea\n          id=\"textBox\"\n          ref={textBoxRef}\n          autoSize={true}\n          size={\"small\"}\n          name=\"story\"\n          value={text}\n          onChange={(e) => setText(e.target.value)}\n          className={`text-box`}\n          // rows={1}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Canvas;\n","/Users/jinmingliu/code/ccc-react-paint/src/left-tool/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/edit/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/components/loading/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/tool.ts",["165"],"/* eslint-disable @typescript-eslint/no-unused-vars */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n\n// 吸色功能\nexport const setStraw = (pos?: Point) => {\n  if (Tool.strawFlag && pos) {\n    // 吸色\n    const color = getPixelColorOnCanvas(Tool.ctx, pos.x, pos!.y);\n    Tool.strawColor = color;\n    Tool.strawFlag = false;\n  } \n \n};\n\n\nexport const getMousePos = (canvas: HTMLCanvasElement, event: MouseEvent|undefined, type?: string,pos?: Point): Point => {\n  const rect = canvas.getBoundingClientRect();\n  const scale = Tool.currentScale || 1\n  if (pos) { \n    return {\n      x: (pos.x - rect.left) / scale,\n      y: (pos.y - rect.top) / scale\n    //   x: (pos.x) / scale - Tool.translate.translatex,\n    // y: (pos.y )/scale -Tool.translate.translatey\n  };\n  }\n  if (event) { \n return {\n    x: (event.clientX - rect.left)/scale,\n    y: (event.clientY - rect.top)/scale\n  };\n  }\n  return {\n    x: 0,\n    y:0\n  }\n};\n\nexport const getTouchPos = (canvas: HTMLCanvasElement, event: TouchEvent): Point => {\n  return {\n    x: event.touches[0].pageX - canvas.offsetLeft,\n    y: event.touches[0].pageY - canvas.offsetTop\n  };\n};\n\nexport const rgbToHex = (r: number, g: number, b: number, a?: number) => {\n  const componentToHex = (c: number) => {\n    const hex = c.toString(16);\n    return hex.length == 1 ? \"0\" + hex : hex;\n  };\n\n  const res = \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n\n  return a ? res + componentToHex(a) : res;\n};\n\nexport const hexToRgb = (hex: string) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n        a: parseInt(result[4], 16)\n      }\n    : null;\n};\n\nexport const getPixelColorOnCanvas = (ctx: CanvasRenderingContext2D, x: number, y: number): string => {\n  const p = ctx.getImageData(x, y, 1, 1).data;\n  return rgbToHex(p[0], p[1], p[2], p[3]);\n};\n\nexport const updateImageData = (origin: ImageData, data: ImageData, fillData: [number, number, number, number]) => {\n  for (let row = 0; row < data.height; row++) {\n    for (let col = 0; col < data.width; col++) {\n      const index = row * data.width * 4 + col * 4;\n      const r1 = data.data[index];\n      const g1 = data.data[index + 1];\n      const b1 = data.data[index + 2];\n      const a1 = data.data[index + 3];\n\n      const r2 = origin.data[index];\n      const g2 = origin.data[index + 1];\n      const b2 = origin.data[index + 2];\n      const a2 = origin.data[index + 3];\n\n      const equalOrigin = r1 === r2 && g1 === g2 && b1 === b2 && a1 === a2;\n      const equalFilling = r1 === fillData[0] && g1 === fillData[1] && b1 === fillData[2] && a1 === fillData[3];\n      if (!(equalOrigin || equalFilling)) {\n        data.data[index] = fillData[0];\n        data.data[index + 1] = fillData[1];\n        data.data[index + 2] = fillData[2];\n        data.data[index + 3] = fillData[3];\n      }\n    }\n  }\n\n  return data;\n};\n\nexport const clacArea = (points: Point) => {\n  return Tool.showArea ? Tool.showArea.find(item => item[0] === points.x && item[1] === points.y):true\n}\n\nexport default class Tool {\n  /**\n   * 线宽\n   */\n  public static lineWidthFactor = 1;\n  /**\n   * 主色\n   */\n  public static fillColormainColor = \"black\";\n  /**\n   * 副色\n   */\n  public static subColor = \"white\";\n\n  // 吸色\n  public static strawColor ='';\n\n  // 背景色\n  public static fillColor = \"#2d2d2d\";\n\n  // textCanvas\n   public static textList: Record<string, any> = {};\n\n\n\n\n  public static zoom = {\n    scaleX:1,\n    scaleY:1\n  }\n  public currentScale = 1\n\n  public strawFlag = false\n\n  public static ctx: CanvasRenderingContext2D;\n  //可画区域\n  public static showArea: Array<[number, number]> | null;\n  static currentScale: number;\n  static show_offset: any;\n  static strawFlag: boolean;\n  static mainColor: string;\n  static translate: { translatex: number; translatey: number; };\n\n  public onMouseDown(event: MouseEvent): void {\n    //\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    //\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    //\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    //\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    //\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    //\n  }\n\n  public onKeyDown(event: KeyboardEvent): void { \n    //\n  }\n \n}\n","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/eraser.ts",["166"],"import { ColorType } from \"../toolType\";\nimport Tool, { Point, getMousePos, getPixelColorOnCanvas, getTouchPos, hexToRgb, updateImageData, clacArea } from \"./tool\";\nclass Eraser extends Tool {\n  protected lineWidthBase = 1;\n  private mouseDown = false;\n  private color = \"transparent\";\n  private saveImageData?: ImageData;\n  private previousPos: Point = {\n    x: 0,\n    y: 0\n  };\n  public constructor(lineSize:number) {\n    super();\n    this.lineWidthBase = lineSize;\n    this.color = \"transparent\";\n  }\n  private operateStart(pos: Point) {\n    if (!Tool.ctx) return;\n    this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    this.mouseDown = true;\n    this.color = getPixelColorOnCanvas(Tool.ctx, pos.x - 2, pos.y - 2);\n    Tool.ctx.lineWidth = this.lineWidthBase;\n    Tool.ctx.strokeStyle = this.color;\n    Tool.ctx.lineJoin = \"round\";\n    Tool.ctx.lineCap = \"round\";\n    Tool.ctx.beginPath();\n    this.previousPos = pos;\n  }\n  private operateMove(pos: Point) {\n    if (this.mouseDown) {\n      Tool.ctx.moveTo(this.previousPos.x, this.previousPos.y);\n      const c = 0.5 * (this.previousPos.x + pos.x);\n      const d = 0.5 * (this.previousPos.y + pos.y);\n      Tool.ctx.quadraticCurveTo(c, d, pos.x, pos.y);\n      Tool.ctx.stroke();\n      this.previousPos = pos;\n    }\n  }\n  private operateEnd() {\n    if (this.mouseDown) {\n      Tool.ctx.closePath();\n      this.mouseDown = false;\n      let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n      const colorRgb = hexToRgb(this.color);\n      if (colorRgb && this.saveImageData) {\n        imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, colorRgb.a]);\n        Tool.ctx.putImageData(imageData, 0, 0);\n      }\n    }\n  }\n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n\n      if (clacArea(mousePos)) { \n    this.operateStart(mousePos);\n    }\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    event.preventDefault();\n    this.operateEnd();\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    this.operateMove(mousePos);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchPos);\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateMove(touchPos);\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this.operateEnd();\n  }\n}\n\nexport default Eraser;\n","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorExtract.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorFill.ts",["167"],"import Tool, { getMousePos, getTouchPos,setStraw, Point } from \"./tool\";\nimport Color from \"color\";\nimport { parseColorString } from \"../colorChange\";\n\n/**\n * 高效率的填充算法\n * 参考地址: http://www.williammalone.com/articles/html5-canvas-javascript-paint-bucket-tool/\n */\nconst efficentFloodFill = (\n  ctx: CanvasRenderingContext2D,\n  startX: number,\n  startY: number,\n  fillColor: number[]\n) => {\n  // 保证 startX 和 startY 是正整数\n  // 经测试，在触屏设备中 startX 和 startY 可能是小数，造成填充功能无法正确填充\n  startX = Math.round(startX);\n  startY = Math.round(startY);\n  const pixelStack: [number, number][] = [\n    [Math.round(startX), Math.round(startY)],\n  ];\n  const canvasWidth = ctx.canvas.width,\n  canvasHeight = ctx.canvas.height;\n  const startPos = (startY * canvasWidth + startX) * 4;\n  const colorLayer = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n  const startColor: number[]= [\n    colorLayer.data[startPos],\n    colorLayer.data[startPos + 1],\n    colorLayer.data[startPos + 2],\n    colorLayer.data[startPos + 3],\n  ];\n  const updatedPoint: Record<string | number, boolean> = {};\n\n  if (\n    startColor[0] === fillColor[0] &&\n    startColor[1] === fillColor[1] &&\n    startColor[2] === fillColor[2] && \n    startColor[3] === fillColor[3]\n  )\n    return;\n  //const newData = [];\n  while (pixelStack.length > 0) {\n    const newPos = pixelStack.pop() as [number, number];\n    const x = newPos[0];\n    let y = newPos[1];\n    let pixelPos = (y * canvasWidth + x) * 4;\n    while (y-- >= 0 && matchColor(colorLayer, pixelPos, startColor)) {\n      pixelPos -= canvasWidth * 4;\n    }\n    pixelPos += canvasWidth * 4;\n    ++y;\n    let reachLeft = false,\n      reachRight = false;\n\n    if (updatedPoint[pixelPos]) {\n      continue;\n    }\n    updatedPoint[pixelPos] = true\n    while (\n      y++ < canvasHeight - 1 &&\n      matchColor(colorLayer, pixelPos, startColor)\n    ) {\n      fillPixel(colorLayer, pixelPos, fillColor);\n      if (x > 0) {\n        if (matchColor(colorLayer, pixelPos - 4, startColor)) {\n          if (!reachLeft) {\n            pixelStack.push([x - 1, y]);\n            reachLeft = true;\n          }\n        } else if (reachLeft) {\n          reachLeft = false;\n        }\n      }\n\n      if (x < canvasWidth - 1) {\n        if (matchColor(colorLayer, pixelPos + 4, startColor)) {\n          if (!reachRight) {\n            pixelStack.push([x + 1, y]);\n            reachRight = true;\n          }\n        } else if (reachRight) {\n          reachRight = false;\n        }\n      }\n\n      pixelPos += canvasWidth * 4;\n    }\n  }\n  ctx.putImageData(colorLayer, 0, 0);\n};\n\n/**\n * 判断两个位置的像素颜色是否相同\n */\nconst matchColor = (\n  colorLayer: ImageData,\n  pixelPos: number,\n  color: number[],\n) => {\n  const r = colorLayer.data[pixelPos];\n  const g = colorLayer.data[pixelPos + 1];\n  const b = colorLayer.data[pixelPos + 2];\n \n  return (\n    Math.abs(r - color[0]) < 30 &&\n    Math.abs(g - color[1]) < 30 &&\n    Math.abs(b - color[2]) < 30\n  );\n};\n\n/**\n * 修改指定ImageData的指定位置像素颜色\n */\nconst fillPixel = (\n  colorLayer: ImageData,\n  pixelPos: number,\n  color:number[]| [number, number, number,number]\n) => {\n  \n  colorLayer.data[pixelPos] = color[0];\n  colorLayer.data[pixelPos + 1] = color[1];\n  colorLayer.data[pixelPos + 2] = color[2];\n  colorLayer.data[pixelPos + 3] = color[3]\n  return colorLayer;\n};\n\nclass ColorFill extends Tool {\n  mouseDownTimer: any;\n  private operateStart(pos: Point) {\n    const showColor = parseColorString(Tool.strawColor || Tool.fillColor ||\"#000000FF\")\n    console.time(\"efficentFloodFill\");\n    const colorArr: number[] = [showColor.r, showColor.g, showColor.b, showColor.a * 255]\n    Promise.resolve().then(() => { \n      efficentFloodFill(Tool.ctx, pos.x, pos.y, colorArr);\n    })\n    console.timeEnd(\"efficentFloodFill\");\n  }\n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n    if(this.mouseDownTimer) return \n    const mousepos = getMousePos(Tool.ctx.canvas, event);\n    setStraw(mousepos);\n    this.operateStart(mousepos);\n\n    this.mouseDownTimer = setTimeout(() => {\n      clearTimeout(this.mouseDownTimer);\n      this.mouseDownTimer = undefined;\n    }, 300);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchpos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchpos);\n  }\n}\n\nexport default ColorFill;\n","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/pen.ts",["168","169"],"import { ColorType } from \"../toolType\";\nimport { hexToRgba, } from \"../colorChange\";\nimport Tool, { Point, getMousePos, setStraw, getTouchPos, hexToRgb,clacArea, updateImageData } from \"./tool\";\n\nclass Pen extends Tool {\n  protected lineWidthBase = 1;\n  protected drawColorType = ColorType.MAIN;\n  protected eraser = \"\";\n  private mouseDown = false;\n  private saveImageData?: ImageData;\n  private previousPos: Point = {\n    x: 0,\n    y: 0\n  };\n  private operateStart(pos: Point) {\n    if (!Tool.ctx) return;\n    setStraw(pos);\n    this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    this.mouseDown = true;\n    const showColor = Tool.strawColor\n      ? Tool.strawColor\n      : this.drawColorType === ColorType.MAIN\n      ? Tool.mainColor\n        : Tool.subColor;\n    const testColor = hexToRgba(showColor)\n    Tool.ctx.lineWidth = Tool.lineWidthFactor * this.lineWidthBase;\n    Tool.ctx.strokeStyle = testColor;\n    Tool.ctx.lineJoin = \"round\";\n    Tool.ctx.lineCap = \"round\";\n    Tool.ctx.beginPath();\n    this.previousPos = pos;\n  }\n  private operateMove(pos: Point) {\n    if (this.mouseDown) {\n      Tool.ctx.moveTo(this.previousPos.x, this.previousPos.y);\n      const c = 0.5 * (this.previousPos.x + pos.x);\n      const d = 0.5 * (this.previousPos.y + pos.y);\n      Tool.ctx.quadraticCurveTo(c, d, pos.x, pos.y);\n      Tool.ctx.stroke();\n      this.previousPos = pos;\n    }\n  }\n  private operateEnd() {\n    if (this.mouseDown) {\n      Tool.ctx.closePath();\n      this.mouseDown = false;\n    //  let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    //    const showColor = Tool.strawColor\n    //   ? Tool.strawColor\n    //   : this.drawColorType === ColorType.MAIN\n    //   ? Tool.mainColor\n    //        : Tool.subColor;\n    //       const testColor = hexToRgba(showColor)\n    // const rgbaColor = parseColorString(testColor)\n    //   const colorRgb = hexToRgb(showColor);\n    //   if (colorRgb && this.saveImageData) {\n    //     imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, 0.5]);\n    //     Tool.ctx.putImageData(imageData, 0, 0);\n    //   }\n    }\n  }\n  \n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    \n    if (clacArea(mousePos)) { \n    this.operateStart(mousePos);\n    }\n\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    event.preventDefault();\n    this.operateEnd();\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    this.operateMove(mousePos);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchPos);\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateMove(touchPos);\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this.operateEnd();\n  }\n}\n\nexport default Pen;\n","/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/event.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/shape.ts",["170","171"],"import {ShapeToolType} from \"../toolType\";\nimport Tool, {Point, getMousePos, getTouchPos,setStraw, hexToRgb,clacArea, updateImageData} from \"./tool\";\n\n/**\n * 根据形状类型，获取要绘制的形状的顶点(圆形，返回圆心)\n * @param type shape type\n * @param sx x coord of start\n * @param sy y coord of start\n * @param ex x coord of end\n * @param ey y coord of end\n */\nconst getVertexs = (type: ShapeToolType, sx: number, sy: number, ex: number, ey: number): Point[] => {\n    const points: Point[] = [];\n    const mx = 0.5 * (sx + ex), my = 0.5 * (sy + ey);\n\n    switch (type) {\n        case ShapeToolType.LINE:\n            points.push({x: sx, y: sy});\n            points.push({x: ex, y: ey});\n            break;\n        case ShapeToolType.RECT:\n            points.push({x: sx, y: sy});\n            points.push({x: ex, y: sy});\n            points.push({x: ex, y: ey});\n            points.push({x: sx, y: ey});\n            break;\n        case ShapeToolType.CIRCLE:\n            points.push({x: 0.5 * (sx + ex), y: 0.5 * (sy + ey)});\n            break;\n        case ShapeToolType.RHOMBUS:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.TRIANGLE:\n            points.push({x: mx, y: sy});\n            points.push({x: sx, y: ey});\n            points.push({x: ex, y: ey});\n            break;\n        case ShapeToolType.PENTAGON:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: 0.5 * (mx + ex), y: ey});\n            points.push({x: 0.5 * (mx + sx), y: ey});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.SEXANGLE:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: 0.5 * (sy + my)});\n            points.push({x: ex, y: 0.5 * (ey + my)});\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: 0.5 * (ey + my)});\n            points.push({x: sx, y: 0.5 * (sy + my)});\n            break;\n        case ShapeToolType.ARROW_TOP:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: my});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: ey});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: ey});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: my});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.ARROW_RIGHT:\n            points.push({x: ex, y: my});\n            points.push({x: mx, y: ey});\n            points.push({x: mx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: sx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: sx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: sy});\n            break;\n        case ShapeToolType.ARROW_DOWN:\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: my});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: my});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: sy});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: sy});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: my});\n            points.push({x: ex, y: my});\n            break;\n        case ShapeToolType.ARROW_LEFT:\n            points.push({x: sx, y: my});\n            points.push({x: mx, y: sy});\n            points.push({x: mx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: ex, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: ex, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: ey});\n            break;\n        case ShapeToolType.FOUR_STAR:\n            const offsetX = 0.125 * (ex - sx), offsetY = 0.125 * (ey - sy);\n            points.push({x: mx, y: sy});\n            points.push({x: mx + offsetX, y: my - offsetY});\n            points.push({x: ex, y: my});\n            points.push({x: mx + offsetX, y: my + offsetY});\n            points.push({x: mx, y: ey});\n            points.push({x: mx - offsetX, y: my + offsetY});\n            points.push({x: sx, y: my});\n            points.push({x: mx - offsetX, y: my - offsetY});\n            break;\n        default:\n            break;\n    }\n    return points;\n};\n\nclass Shape extends Tool {\n    private type: ShapeToolType;\n    private saveImageData?: ImageData;\n    private isMouseDown = false;\n    private mouseDownPos = {x: 0, y: 0};\n    private lineWidthBase = 1;\n    public isDashed = false;\n    private dashLineStyle = [10, 10];\n    static shapeWidth: any;\n    public constructor(type: ShapeToolType, dashed = false) {\n        super();\n        this.type = type;\n        this.isDashed = dashed;\n    }\n\n    public setType(type: ShapeToolType) {\n        this.type = type;\n    }\n\n    private operateStart(pos: { x: number; y: number }) {\n        setStraw(pos)\n        this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n        this.isMouseDown = true;\n        this.mouseDownPos = pos;\n        Tool.ctx.strokeStyle = Tool.mainColor;\n        Tool.ctx.lineWidth = Shape.shapeWidth;//5// Tool.lineWidthFactor * this.lineWidthBase;\n        Tool.ctx.fillStyle = Tool.subColor;\n        if (this.isDashed) {\n            Tool.ctx.setLineDash(this.dashLineStyle);\n        }\n    }\n\n    private operateMove(pos: {x: number; y: number}) {\n        if (this.isMouseDown && this.saveImageData) {\n            const ctx = Tool.ctx;\n            ctx.clearRect(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n\n            ctx.putImageData(this.saveImageData, 0, 0);\n            const vertexs: Point[] = getVertexs(this.type, this.mouseDownPos.x, this.mouseDownPos.y, pos.x, pos.y);\n\n            if (this.type === ShapeToolType.CIRCLE) {\n                ctx.beginPath();\n                ctx.ellipse(vertexs[0].x, vertexs[0].y, Math.abs(0.5 * (pos.x - this.mouseDownPos.x)), Math.abs(0.5 * (pos.y - this.mouseDownPos.y)), 0, 0, Math.PI * 2);\n                ctx.stroke();\n            } else {\n                ctx.beginPath();\n                ctx.moveTo(vertexs[0].x, vertexs[0].y);\n                for (let i = 1; i < vertexs.length; i++) {\n                    ctx.lineTo(vertexs[i].x, vertexs[i].y);\n                }\n                ctx.closePath();\n                ctx.stroke();\n            }\n        }\n    }\n    \n    private operateEnd() {\n        Tool.ctx.setLineDash([]);\n        // let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n        // const colorRgb = hexToRgb(Tool.mainColor);\n        // if (colorRgb && this.saveImageData) {\n        //     imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, colorRgb.a]);\n\n        //     Tool.ctx.putImageData(imageData, 0, 0);\n        // }\n        \n        this.isMouseDown = false;\n        this.saveImageData = undefined;\n    }\n\n    public onMouseDown(event: MouseEvent): void {\n        event.preventDefault();\n        const mousePos = getMousePos(Tool.ctx.canvas, event);\n          if (clacArea(mousePos)) { \n            this.operateStart(mousePos);\n          }\n    }\n\n    public onMouseMove(event: MouseEvent): void {\n        event.preventDefault();\n        const mousePos = getMousePos(Tool.ctx.canvas, event);\n        this.operateMove(mousePos);\n    }\n\n    public onMouseUp(event: MouseEvent): void {\n        event.preventDefault();\n        this.operateEnd();\n    }\n\n    public onTouchStart(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        const canvas = event.target as HTMLCanvasElement;\n        const touchPos = getTouchPos(canvas, event);\n\n        this.operateStart(touchPos);\n    }\n\n    public onTouchMove(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        const canvas = event.target as HTMLCanvasElement;\n        const touchPos = getTouchPos(canvas, event);\n\n        this.operateMove(touchPos);\n    }\n\n    public onTouchEnd(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        this.operateEnd();\n    }\n}\n\nexport default Shape;\n","/Users/jinmingliu/code/ccc-react-paint/src/ToolTypeIcon.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/snapshot/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/pen/index.tsx",["172","173"],"import React, { FC } from \"react\";\nimport { useContext } from \"react\";\nimport { LineWidthContext } from \"@/context\";\nimport IntegerStep from \"../components/slider\";\nimport ColorPanel from \"../components/colorPanel\";\nimport \"./index.less\";\nimport { Tool } from \"../../util/tool\";\n\ninterface PenType {\n  lineSize: number;\n  maxSize: number;\n}\n\nconst ShowPen = (props: PenType) => {\n  const lineWidthContext = useContext(LineWidthContext);\n\n  const { lineSize, maxSize } = props;\n  return (\n    <div className=\"ccc-pen\">\n      <div className=\"ccc-slider-item\">\n        <h3>Brush Thickness</h3>\n        <IntegerStep\n          min={1}\n          max={maxSize}\n          value={lineSize}\n          onPropsChange={(value) => {\n            lineWidthContext.setLineSize(value);\n          }}\n        />\n      </div>\n      <ColorPanel type=\"pen\" className=\"toolbar-item\" />\n    </div>\n  );\n};\n\nexport default ShowPen;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/showShape/index.tsx",["174","175"],"import React, { FC, useEffect } from \"react\";\nimport ShapeComponent from \"../components/shape\";\nimport ColorPanel from \"../components/colorPanel\";\nimport { DownOutlined } from \"@ant-design/icons\";\nimport IntegerStep from \"../components/slider\";\nimport { Shape } from \"../../util/tool\";\nimport arrow from \"@/icon/arrow.svg\";\nimport \"./index.less\";\n\ninterface shapeType {\n  lineSize: number;\n  maxSize: number;\n}\n\nconst showShape = (props: shapeType) => {\n  const { lineSize, maxSize } = props;\n\n  useEffect(() => {\n    Shape.shapeWidth = lineSize / 2;\n  }, []);\n  return (\n    <div className=\"ccc-shape\">\n      <div className=\"ccc-shape-item\">\n        <h3>Shape Thickness</h3>\n        <IntegerStep\n          min={1}\n          max={Math.floor(maxSize / 2)}\n          value={Shape.shapeWidth || lineSize / 2}\n          onPropsChange={(value) => {\n            Shape.shapeWidth = value;\n          }}\n        />\n      </div>\n      <h3 className=\"ccc-shape-title\">\n        <span>Shapes</span>\n        <img src={arrow}></img>\n      </h3>\n      <ShapeComponent className=\"toolbar-item\" />\n      <ColorPanel className=\"toolbar-item\" />\n    </div>\n  );\n};\n\nexport default showShape;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/formatColor/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/text/index.tsx",["176"],"/Users/jinmingliu/code/ccc-react-paint/src/right/earser/index.tsx",["177"],"import React, { FC } from \"react\";\nimport { useContext } from \"react\";\nimport { LineWidthContext } from \"@/context\";\nimport IntegerStep from \"../components/slider\";\nimport \"./index.less\";\n\ninterface earserType {\n  lineSize: number;\n  maxSize: number;\n}\n\nconst Eraser = (props: earserType) => {\n  const { lineSize, maxSize } = props;\n  const lineWidthContext = useContext(LineWidthContext);\n\n  return (\n    <div className=\"ccc-pen\">\n      <div className=\"ccc-slider-item\">\n        <h3>Eraser Thickness</h3>\n        <IntegerStep\n          min={1}\n          max={maxSize}\n          value={lineSize}\n          onPropsChange={(value) => {\n            lineWidthContext.setLineSize(value);\n          }}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Eraser;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/components/colorPanel/index.tsx",["178"],"import React from \"react\";\nimport { useContext } from \"react\";\nimport { ColorContext, ToolTypeContext } from \"@/context\";\nimport { Tool } from \"../../../util/tool\";\nimport \"./index.less\";\nimport { useState } from \"react\";\nimport { useEffect } from \"react\";\nimport { SketchPicker } from \"react-color\";\nimport { getRandomColor } from \"../../../utils\";\nimport { strawIcon } from \"../../../ToolTypeIcon\";\nimport { toHexString } from \"../../../util/colorChange\";\n\ninterface ColorPanelProps {\n  className?: string;\n  testTool?: Tool;\n  color?: string;\n  type?: string;\n  onChange?: (color: string) => void;\n}\n\nconst activeColorTypeCls = \"active-color-type\";\n\nconst ColorPanel: React.FC<ColorPanelProps> = (props) => {\n  const { className, type, color, onChange, testTool } = props;\n  const colorStr = type === \"pen\" ? getRandomColor() : color || \"#000000FF\";\n  const [showColor, setColor] = useState(colorStr);\n  const colorContext = useContext(ColorContext);\n  const ToolContext = useContext(ToolTypeContext);\n\n  useEffect(() => {\n    colorContext.setColor(showColor);\n  }, [showColor, testTool]);\n\n  const getStrawColor = () => {\n    const startTime = new Date().getTime();\n    const intervalId = setInterval(function () {\n      const endTime = new Date().getTime();\n      if (Math.abs(endTime - startTime) >= 10 * 60 * 1000) {\n        clearInterval(intervalId); //清除定时器 ,超过10分钟没有吸色功能 清楚定时器\n        ToolContext.setStrawType(false);\n      }\n      if (Tool.strawColor) {\n        setColor(Tool.strawColor);\n        ToolContext.setStrawType(false);\n        clearInterval(intervalId); //清除定时器\n      }\n    }, 200);\n  };\n\n  const handleChange = (color: any) => {\n    if (Tool.strawColor !== \"\") {\n      Tool.strawColor = \"\";\n    }\n    const hexColor: string = toHexString(color.rgb);\n    setColor(hexColor);\n    Tool.strawColor = \"\";\n    // Tool.colorPicker = \"\";\n    if (onChange) {\n      onChange(hexColor);\n    }\n  };\n\n  useEffect(() => {\n    const nodeColor = document.getElementsByClassName(\n      \"ccc-paint-colorBox-picker\"\n    )[0];\n    const fileList = nodeColor?.getElementsByClassName(\"flexbox-fix\");\n    if (fileList[0]) {\n      fileList[0].setAttribute(\"style\", \"padding-left:12%;display: flex\");\n    }\n  }, []);\n\n  return (\n    <div className={className ? `colorpanel ${className}` : \"colorpanel\"}>\n      <div className=\"content\">\n        <h3>Color</h3>\n        <div className=\"material-color-box\">\n          <SketchPicker\n            className=\"ccc-paint-colorBox-picker\"\n            width=\"100%\"\n            disableAlpha={false}\n            color={showColor}\n            onChange={handleChange}\n          />\n          {/* {type !== \"text\" && ( */}\n          <span\n            className={`straw-color ${Tool.strawFlag ? \"select-item\" : \"\"}`}\n            onClick={() => {\n              Tool.strawFlag = true;\n              Tool.strawColor = \"\";\n              ToolContext.setStrawType(true);\n              getStrawColor();\n            }}\n          >\n            {strawIcon}\n          </span>\n          {/* )} */}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ColorPanel;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/components/slider/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/components/shape/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/Text.ts",["179","180","181","182","183","184"],"/Users/jinmingliu/code/ccc-react-paint/src/util/colorChange.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorChange.ts",[],{"ruleId":"185","severity":1,"message":"186","line":1,"column":17,"nodeType":"187","messageId":"188","endLine":1,"endColumn":20},{"ruleId":"185","severity":1,"message":"189","line":1,"column":17,"nodeType":"187","messageId":"188","endLine":1,"endColumn":24},{"ruleId":"185","severity":1,"message":"190","line":65,"column":5,"nodeType":"187","messageId":"188","endLine":65,"endColumn":13},{"ruleId":"191","severity":1,"message":"192","line":250,"column":9,"nodeType":"193","messageId":"194","endLine":250,"endColumn":18,"suggestions":"195"},{"ruleId":"191","severity":1,"message":"192","line":257,"column":23,"nodeType":"193","messageId":"194","endLine":257,"endColumn":36,"suggestions":"196"},{"ruleId":"191","severity":1,"message":"192","line":288,"column":23,"nodeType":"193","messageId":"194","endLine":288,"endColumn":36,"suggestions":"197"},{"ruleId":"191","severity":1,"message":"192","line":296,"column":22,"nodeType":"193","messageId":"194","endLine":296,"endColumn":32,"suggestions":"198"},{"ruleId":"191","severity":1,"message":"192","line":297,"column":21,"nodeType":"193","messageId":"194","endLine":297,"endColumn":31,"suggestions":"199"},{"ruleId":"191","severity":1,"message":"192","line":397,"column":23,"nodeType":"193","messageId":"194","endLine":397,"endColumn":36,"suggestions":"200"},{"ruleId":"185","severity":1,"message":"201","line":398,"column":31,"nodeType":"187","messageId":"188","endLine":398,"endColumn":37},{"ruleId":"191","severity":1,"message":"192","line":399,"column":37,"nodeType":"193","messageId":"194","endLine":399,"endColumn":47,"suggestions":"202"},{"ruleId":"185","severity":1,"message":"203","line":400,"column":20,"nodeType":"187","messageId":"188","endLine":400,"endColumn":31},{"ruleId":"185","severity":1,"message":"204","line":400,"column":41,"nodeType":"187","messageId":"188","endLine":400,"endColumn":53},{"ruleId":"191","severity":1,"message":"192","line":401,"column":7,"nodeType":"193","messageId":"194","endLine":401,"endColumn":17,"suggestions":"205"},{"ruleId":"191","severity":1,"message":"192","line":446,"column":7,"nodeType":"193","messageId":"194","endLine":446,"endColumn":14,"suggestions":"206"},{"ruleId":"185","severity":1,"message":"207","line":464,"column":13,"nodeType":"187","messageId":"188","endLine":464,"endColumn":20},{"ruleId":"185","severity":1,"message":"208","line":464,"column":22,"nodeType":"187","messageId":"188","endLine":464,"endColumn":29},{"ruleId":"191","severity":1,"message":"192","line":486,"column":7,"nodeType":"193","messageId":"194","endLine":486,"endColumn":14,"suggestions":"209"},{"ruleId":"191","severity":1,"message":"192","line":12,"column":58,"nodeType":"193","messageId":"194","endLine":12,"endColumn":62,"suggestions":"210"},{"ruleId":"185","severity":1,"message":"211","line":1,"column":10,"nodeType":"187","messageId":"188","endLine":1,"endColumn":19},{"ruleId":"185","severity":1,"message":"212","line":2,"column":8,"nodeType":"187","messageId":"188","endLine":2,"endColumn":13},{"ruleId":"185","severity":1,"message":"213","line":3,"column":59,"nodeType":"187","messageId":"188","endLine":3,"endColumn":67},{"ruleId":"185","severity":1,"message":"214","line":3,"column":78,"nodeType":"187","messageId":"188","endLine":3,"endColumn":93},{"ruleId":"185","severity":1,"message":"213","line":2,"column":57,"nodeType":"187","messageId":"188","endLine":2,"endColumn":65},{"ruleId":"185","severity":1,"message":"214","line":2,"column":76,"nodeType":"187","messageId":"188","endLine":2,"endColumn":91},{"ruleId":"185","severity":1,"message":"215","line":1,"column":17,"nodeType":"187","messageId":"188","endLine":1,"endColumn":19},{"ruleId":"185","severity":1,"message":"216","line":7,"column":10,"nodeType":"187","messageId":"188","endLine":7,"endColumn":14},{"ruleId":"185","severity":1,"message":"215","line":1,"column":17,"nodeType":"187","messageId":"188","endLine":1,"endColumn":19},{"ruleId":"185","severity":1,"message":"217","line":4,"column":10,"nodeType":"187","messageId":"188","endLine":4,"endColumn":22},{"ruleId":"185","severity":1,"message":"217","line":9,"column":10,"nodeType":"187","messageId":"188","endLine":9,"endColumn":22},{"ruleId":"185","severity":1,"message":"215","line":1,"column":17,"nodeType":"187","messageId":"188","endLine":1,"endColumn":19},{"ruleId":"185","severity":1,"message":"218","line":21,"column":7,"nodeType":"187","messageId":"188","endLine":21,"endColumn":25},{"ruleId":"185","severity":1,"message":"219","line":1,"column":10,"nodeType":"187","messageId":"188","endLine":1,"endColumn":37},{"ruleId":"185","severity":1,"message":"220","line":52,"column":23,"nodeType":"187","messageId":"188","endLine":52,"endColumn":32},{"ruleId":"185","severity":1,"message":"221","line":52,"column":34,"nodeType":"187","messageId":"188","endLine":52,"endColumn":43},{"ruleId":"185","severity":1,"message":"222","line":52,"column":45,"nodeType":"187","messageId":"188","endLine":52,"endColumn":58},{"ruleId":"185","severity":1,"message":"223","line":104,"column":27,"nodeType":"187","messageId":"188","endLine":104,"endColumn":37},{"ruleId":"185","severity":1,"message":"224","line":302,"column":43,"nodeType":"187","messageId":"188","endLine":302,"endColumn":53},"@typescript-eslint/no-unused-vars","'Ref' is defined but never used.","Identifier","unusedVar","'useMemo' is defined but never used.","'setColor' is assigned a value but never used.","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull",["225"],["226"],["227"],["228"],["229"],["230"],"'deltaX' is assigned a value but never used.",["231"],"'canvasWidth' is assigned a value but never used.","'canvasHeight' is assigned a value but never used.",["232"],["233"],"'clientX' is assigned a value but never used.","'clientY' is assigned a value but never used.",["234"],["235"],"'ColorType' is defined but never used.","'Color' is defined but never used.","'hexToRgb' is defined but never used.","'updateImageData' is defined but never used.","'FC' is defined but never used.","'Tool' is defined but never used.","'DownOutlined' is defined but never used.","'activeColorTypeCls' is assigned a value but never used.","'numberLiteralTypeAnnotation' is defined but never used.","'x' is defined but never used.","'y' is defined but never used.","'arr' is defined but never used.","'fontFamily' is assigned a value but never used.","'lineHeight' is assigned a value but never used.",{"messageId":"236","fix":"237","desc":"238"},{"messageId":"236","fix":"239","desc":"238"},{"messageId":"236","fix":"240","desc":"238"},{"messageId":"236","fix":"241","desc":"238"},{"messageId":"236","fix":"242","desc":"238"},{"messageId":"236","fix":"243","desc":"238"},{"messageId":"236","fix":"244","desc":"238"},{"messageId":"236","fix":"245","desc":"238"},{"messageId":"236","fix":"246","desc":"238"},{"messageId":"236","fix":"247","desc":"238"},{"messageId":"236","fix":"248","desc":"238"},"suggestOptionalChain",{"range":"249","text":"250"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"251","text":"250"},{"range":"252","text":"250"},{"range":"253","text":"250"},{"range":"254","text":"250"},{"range":"255","text":"250"},{"range":"256","text":"250"},{"range":"257","text":"250"},{"range":"258","text":"250"},{"range":"259","text":"250"},{"range":"260","text":"250"},[6644,6645],"?",[6817,6818],[7936,7937],[8175,8176],[8220,8221],[10763,10764],[10884,10885],[10983,10984],[11951,11952],[13309,13310],[262,263]]