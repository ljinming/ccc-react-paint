[{"/Users/jinmingliu/work/ccc-react-paint/src/index.tsx":"1","/Users/jinmingliu/code/ccc-react-paint/src/index.tsx":"2","/Users/jinmingliu/code/ccc-react-paint/src/CCCPaint.tsx":"3","/Users/jinmingliu/code/ccc-react-paint/src/util/toolType.ts":"4","/Users/jinmingliu/code/ccc-react-paint/src/utils.tsx":"5","/Users/jinmingliu/code/ccc-react-paint/src/context/index.ts":"6","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/index.ts":"7","/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/index.ts":"8","/Users/jinmingliu/code/ccc-react-paint/src/canvas/index.tsx":"9","/Users/jinmingliu/code/ccc-react-paint/src/left-tool/index.tsx":"10","/Users/jinmingliu/code/ccc-react-paint/src/right/index.tsx":"11","/Users/jinmingliu/code/ccc-react-paint/src/edit/index.tsx":"12","/Users/jinmingliu/code/ccc-react-paint/src/components/loading/index.tsx":"13","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/tool.ts":"14","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/eraser.ts":"15","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorExtract.ts":"16","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorFill.ts":"17","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/pen.ts":"18","/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/event.ts":"19","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/shape.ts":"20","/Users/jinmingliu/code/ccc-react-paint/src/ToolTypeIcon.tsx":"21","/Users/jinmingliu/code/ccc-react-paint/src/util/snapshot/index.ts":"22","/Users/jinmingliu/code/ccc-react-paint/src/right/pen/index.tsx":"23","/Users/jinmingliu/code/ccc-react-paint/src/right/showShape/index.tsx":"24","/Users/jinmingliu/code/ccc-react-paint/src/right/formatColor/index.tsx":"25","/Users/jinmingliu/code/ccc-react-paint/src/right/text/index.tsx":"26","/Users/jinmingliu/code/ccc-react-paint/src/right/earser/index.tsx":"27","/Users/jinmingliu/code/ccc-react-paint/src/right/components/colorPanel/index.tsx":"28","/Users/jinmingliu/code/ccc-react-paint/src/right/components/slider/index.tsx":"29","/Users/jinmingliu/code/ccc-react-paint/src/right/components/shape/index.tsx":"30","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/Text.ts":"31","/Users/jinmingliu/code/ccc-react-paint/src/util/colorChange.ts":"32","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorChange.ts":"33","/Users/jinmingliu/work/ccc-react-paint/src/CCCPaint.tsx":"34","/Users/jinmingliu/work/ccc-react-paint/src/util/toolType.ts":"35","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/tool.ts":"36","/Users/jinmingliu/work/ccc-react-paint/src/utils.tsx":"37","/Users/jinmingliu/work/ccc-react-paint/src/context/index.ts":"38","/Users/jinmingliu/work/ccc-react-paint/src/util/dispatcher/index.ts":"39","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/index.ts":"40","/Users/jinmingliu/work/ccc-react-paint/src/left-tool/index.tsx":"41","/Users/jinmingliu/work/ccc-react-paint/src/edit/index.tsx":"42","/Users/jinmingliu/work/ccc-react-paint/src/canvas/index.tsx":"43","/Users/jinmingliu/work/ccc-react-paint/src/right/index.tsx":"44","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/colorExtract.ts":"45","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/pen.ts":"46","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/eraser.ts":"47","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/colorFill.ts":"48","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/Text.ts":"49","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/shape.ts":"50","/Users/jinmingliu/work/ccc-react-paint/src/util/dispatcher/event.ts":"51","/Users/jinmingliu/work/ccc-react-paint/src/ToolTypeIcon.tsx":"52","/Users/jinmingliu/work/ccc-react-paint/src/util/colorChange.ts":"53","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/colorChange.ts":"54","/Users/jinmingliu/work/ccc-react-paint/src/util/snapshot/index.ts":"55","/Users/jinmingliu/work/ccc-react-paint/src/right/pen/index.tsx":"56","/Users/jinmingliu/work/ccc-react-paint/src/right/showShape/index.tsx":"57","/Users/jinmingliu/work/ccc-react-paint/src/right/earser/index.tsx":"58","/Users/jinmingliu/work/ccc-react-paint/src/right/text/index.tsx":"59","/Users/jinmingliu/work/ccc-react-paint/src/right/formatColor/index.tsx":"60","/Users/jinmingliu/work/ccc-react-paint/src/right/components/colorPanel/index.tsx":"61","/Users/jinmingliu/work/ccc-react-paint/src/right/components/slider/index.tsx":"62","/Users/jinmingliu/work/ccc-react-paint/src/right/components/shape/index.tsx":"63","/Users/jinmingliu/work/ccc-react-paint/src/piexCanvas/index.tsx":"64","/Users/jinmingliu/work/ccc-react-paint/src/piexCanvas/Pixel.tsx":"65","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/pixelUtil.tsx":"66"},{"size":161,"mtime":1659344513878,"results":"67","hashOfConfig":"68"},{"size":161,"mtime":1657536349590,"results":"69","hashOfConfig":"70"},{"size":8396,"mtime":1658114899070,"results":"71","hashOfConfig":"70"},{"size":918,"mtime":1657536349596,"results":"72","hashOfConfig":"70"},{"size":2069,"mtime":1657536389590,"results":"73","hashOfConfig":"70"},{"size":1493,"mtime":1657851440095,"results":"74","hashOfConfig":"70"},{"size":283,"mtime":1657785817425,"results":"75","hashOfConfig":"70"},{"size":2010,"mtime":1657536349594,"results":"76","hashOfConfig":"70"},{"size":16320,"mtime":1657875303337,"results":"77","hashOfConfig":"70"},{"size":3164,"mtime":1657536389585,"results":"78","hashOfConfig":"70"},{"size":1368,"mtime":1657870424040,"results":"79","hashOfConfig":"70"},{"size":1629,"mtime":1657536389585,"results":"80","hashOfConfig":"70"},{"size":363,"mtime":1657854653271,"results":"81","hashOfConfig":"70"},{"size":4386,"mtime":1657795254133,"results":"82","hashOfConfig":"70"},{"size":2904,"mtime":1657789065498,"results":"83","hashOfConfig":"70"},{"size":1045,"mtime":1657536389588,"results":"84","hashOfConfig":"70"},{"size":4506,"mtime":1657784616619,"results":"85","hashOfConfig":"70"},{"size":3306,"mtime":1657784810620,"results":"86","hashOfConfig":"70"},{"size":136,"mtime":1657536349594,"results":"87","hashOfConfig":"70"},{"size":8338,"mtime":1657786077495,"results":"88","hashOfConfig":"70"},{"size":13540,"mtime":1657536389583,"results":"89","hashOfConfig":"70"},{"size":988,"mtime":1657536389587,"results":"90","hashOfConfig":"70"},{"size":906,"mtime":1657786175794,"results":"91","hashOfConfig":"70"},{"size":1172,"mtime":1657876886830,"results":"92","hashOfConfig":"70"},{"size":720,"mtime":1658116303796,"results":"93","hashOfConfig":"70"},{"size":3960,"mtime":1658116464418,"results":"94","hashOfConfig":"70"},{"size":763,"mtime":1657870516518,"results":"95","hashOfConfig":"70"},{"size":3140,"mtime":1657861495989,"results":"96","hashOfConfig":"70"},{"size":961,"mtime":1657876951287,"results":"97","hashOfConfig":"70"},{"size":4046,"mtime":1658112783888,"results":"98","hashOfConfig":"70"},{"size":10471,"mtime":1658115064126,"results":"99","hashOfConfig":"70"},{"size":3956,"mtime":1657765328572,"results":"100","hashOfConfig":"70"},{"size":4190,"mtime":1657871108410,"results":"101","hashOfConfig":"70"},{"size":12272,"mtime":1659696529318,"results":"102","hashOfConfig":"68"},{"size":918,"mtime":1659344513891,"results":"103","hashOfConfig":"68"},{"size":4620,"mtime":1659697707406,"results":"104","hashOfConfig":"68"},{"size":2117,"mtime":1659505971382,"results":"105","hashOfConfig":"68"},{"size":1493,"mtime":1659344513876,"results":"106","hashOfConfig":"68"},{"size":2010,"mtime":1659344513887,"results":"107","hashOfConfig":"68"},{"size":283,"mtime":1659344550522,"results":"108","hashOfConfig":"68"},{"size":3271,"mtime":1659694965898,"results":"109","hashOfConfig":"68"},{"size":1629,"mtime":1659497277593,"results":"110","hashOfConfig":"68"},{"size":16320,"mtime":1659344550517,"results":"111","hashOfConfig":"68"},{"size":1368,"mtime":1659344550520,"results":"112","hashOfConfig":"68"},{"size":1045,"mtime":1659344513889,"results":"113","hashOfConfig":"68"},{"size":3742,"mtime":1659694698797,"results":"114","hashOfConfig":"68"},{"size":3547,"mtime":1659687780049,"results":"115","hashOfConfig":"68"},{"size":4827,"mtime":1659697645327,"results":"116","hashOfConfig":"68"},{"size":10471,"mtime":1659344550521,"results":"117","hashOfConfig":"68"},{"size":8254,"mtime":1659689789816,"results":"118","hashOfConfig":"68"},{"size":136,"mtime":1659344513887,"results":"119","hashOfConfig":"68"},{"size":13540,"mtime":1659344513874,"results":"120","hashOfConfig":"68"},{"size":3956,"mtime":1659344550521,"results":"121","hashOfConfig":"68"},{"size":4190,"mtime":1659344550521,"results":"122","hashOfConfig":"68"},{"size":1483,"mtime":1659692603653,"results":"123","hashOfConfig":"68"},{"size":906,"mtime":1659344550520,"results":"124","hashOfConfig":"68"},{"size":1172,"mtime":1659344550520,"results":"125","hashOfConfig":"68"},{"size":763,"mtime":1659344550519,"results":"126","hashOfConfig":"68"},{"size":3960,"mtime":1659344550521,"results":"127","hashOfConfig":"68"},{"size":720,"mtime":1659344550519,"results":"128","hashOfConfig":"68"},{"size":3140,"mtime":1659344550518,"results":"129","hashOfConfig":"68"},{"size":961,"mtime":1659344550519,"results":"130","hashOfConfig":"68"},{"size":4046,"mtime":1659344550518,"results":"131","hashOfConfig":"68"},{"size":16025,"mtime":1659696495028,"results":"132","hashOfConfig":"68"},{"size":2622,"mtime":1659692735189,"results":"133","hashOfConfig":"68"},{"size":3742,"mtime":1659694925842,"results":"134","hashOfConfig":"68"},{"filePath":"135","messages":"136","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},"1mdxdl2",{"filePath":"138","messages":"139","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},"7p77ne",{"filePath":"141","messages":"142","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"143","messages":"144","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"145","messages":"146","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"147","messages":"148","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"149","messages":"150","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"151","messages":"152","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"153","messages":"154","errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"155","usedDeprecatedRules":"140"},{"filePath":"156","messages":"157","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"158","messages":"159","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"160","messages":"161","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"162","messages":"163","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"164","messages":"165","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"166","usedDeprecatedRules":"140"},{"filePath":"167","messages":"168","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"169","usedDeprecatedRules":"140"},{"filePath":"170","messages":"171","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"172","messages":"173","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"174","usedDeprecatedRules":"140"},{"filePath":"175","messages":"176","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"177","usedDeprecatedRules":"140"},{"filePath":"178","messages":"179","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"180","messages":"181","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"182","usedDeprecatedRules":"140"},{"filePath":"183","messages":"184","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"185","messages":"186","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"187","messages":"188","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"189","usedDeprecatedRules":"140"},{"filePath":"190","messages":"191","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"192","usedDeprecatedRules":"140"},{"filePath":"193","messages":"194","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"195","messages":"196","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"197","messages":"198","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"199","usedDeprecatedRules":"140"},{"filePath":"200","messages":"201","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"202","usedDeprecatedRules":"140"},{"filePath":"203","messages":"204","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"205","messages":"206","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"207","messages":"208","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"209","messages":"210","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"211","messages":"212","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"213","messages":"214","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"215","messages":"216","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"217","messages":"218","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"219","messages":"220","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"221","messages":"222","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"223","messages":"224","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"225","messages":"226","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"227","messages":"228","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"229","usedDeprecatedRules":"137"},{"filePath":"230","messages":"231","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"232","messages":"233","errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"155","usedDeprecatedRules":"137"},{"filePath":"234","messages":"235","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"236","messages":"237","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"238","messages":"239","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"240","usedDeprecatedRules":"137"},{"filePath":"241","messages":"242","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"243","usedDeprecatedRules":"137"},{"filePath":"244","messages":"245","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"246","messages":"247","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"248","usedDeprecatedRules":"137"},{"filePath":"249","messages":"250","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"251","usedDeprecatedRules":"137"},{"filePath":"252","messages":"253","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"254","messages":"255","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"256","messages":"257","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"258","messages":"259","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"260","messages":"261","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"262","messages":"263","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"189","usedDeprecatedRules":"137"},{"filePath":"264","messages":"265","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"192","usedDeprecatedRules":"137"},{"filePath":"266","messages":"267","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"199","usedDeprecatedRules":"137"},{"filePath":"268","messages":"269","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"270","usedDeprecatedRules":"137"},{"filePath":"271","messages":"272","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"273","messages":"274","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"202","usedDeprecatedRules":"137"},{"filePath":"275","messages":"276","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"277","messages":"278","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"137"},{"filePath":"279","messages":"280","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"281","messages":"282","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"283","usedDeprecatedRules":"137"},{"filePath":"284","messages":"285","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"286","usedDeprecatedRules":"137"},"/Users/jinmingliu/work/ccc-react-paint/src/index.tsx",[],[],"/Users/jinmingliu/code/ccc-react-paint/src/index.tsx",[],[],"/Users/jinmingliu/code/ccc-react-paint/src/CCCPaint.tsx",["287"],"/Users/jinmingliu/code/ccc-react-paint/src/util/toolType.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/utils.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/context/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/canvas/index.tsx",["288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304"],"import React, { useMemo } from \"react\";\nimport \"./index.less\";\nimport { useEffect } from \"react\";\nimport { useRef } from \"react\";\nimport { Input } from \"antd\";\n\nimport {\n  LineWidthType,\n  ShapeOutlineType,\n  ShapeToolType,\n  ToolType,\n} from \"../util/toolType\";\nimport { FC } from \"react\";\nimport { useState } from \"react\";\nimport { Pen, Tool, Eraser, ColorFill, Text } from \"../util/tool\";\nimport Shape from \"../util/tool/shape\";\nimport { useContext } from \"react\";\nimport { DispatcherContext } from \"../context\";\nimport { CLEAR_EVENT, REDO_EVENT, UNDO_EVENT } from \"../util/dispatcher/event\";\nimport SnapShot from \"../util/snapshot\";\nimport cursorPen from \"@/assets/icon/cursorPen.jpg\";\nimport cursorErase from \"@/assets/icon/cursorErase.jpg\";\nimport straw from \"@/assets/icon/straw.jpg\";\nimport bucket from \"@/assets/icon/bucket.jpg\";\nconst { TextArea } = Input;\n\ninterface CanvasProps {\n  toolType: ToolType;\n  shapeType: ShapeToolType;\n  shapeOutlineType: ShapeOutlineType;\n  lineWidthType: LineWidthType;\n  strawType: boolean;\n  mainColor: string;\n  subColor: string;\n  lineSize?: number;\n  fillColor: string;\n  fontStyle: any;\n  imgSrc?: string;\n  CanvasSize?: {\n    width: number;\n    height: number;\n  };\n  id: string;\n  background?: string;\n  onSize?: (value: any) => void;\n  setColor: (value: string) => void;\n}\n\nlet show_scale = 1;\n\nlet translatex = 0;\nlet translatey = 0;\n\nconst maxScale = 6;\nconst minScale = 0.1;\nconst scaleStep = 0.1;\n\nconst Canvas: FC<CanvasProps> = (props) => {\n  const {\n    id,\n    toolType,\n    lineWidthType,\n    mainColor,\n    subColor,\n    setColor,\n    CanvasSize,\n    fillColor,\n    shapeType,\n    shapeOutlineType,\n    fontStyle,\n    imgSrc,\n    background,\n    strawType,\n    lineSize = 1,\n  } = props;\n  const [tool, setTool] = useState<Tool>();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const allCanvasRef = useRef<HTMLDivElement>(null);\n  const canvasTextRef = useRef<HTMLDivElement>(null);\n  const textBoxRef = useRef<HTMLTextAreaElement>(null);\n  const dispatcherContext = useContext(DispatcherContext);\n  const [snapshot] = useState<SnapShot>(new SnapShot());\n  const [text, setText] = useState(\"\");\n\n  useEffect(() => {\n    showCanvasCursor();\n    switch (toolType) {\n      case ToolType.PEN:\n        setTool(new Pen());\n        break;\n      case ToolType.ERASER:\n        setTool(new Eraser(lineSize));\n        break;\n      // case ToolType.COLOR_EXTRACT:\n      //   setTool(new ColorExtract(setColor));\n      //   break;\n      case ToolType.COLOR_FILL:\n        setTool(new ColorFill());\n        break;\n      case ToolType.TEXT:\n        setTool(new Text(fontStyle));\n        break;\n      case ToolType.SHAPE:\n        setTool(\n          new Shape(shapeType, shapeOutlineType === ShapeOutlineType.DOTTED)\n        );\n        break;\n      default:\n        break;\n    }\n  }, [toolType, shapeType, fontStyle, lineSize]);\n\n  useEffect(() => {\n    if (tool instanceof Shape) {\n      tool.isDashed = shapeOutlineType === ShapeOutlineType.DOTTED;\n    }\n  }, [shapeOutlineType]);\n\n  useEffect(() => {\n    switch (lineWidthType) {\n      case LineWidthType.THIN:\n        Tool.lineWidthFactor = 1;\n        break;\n      case LineWidthType.MIDDLE:\n        Tool.lineWidthFactor = 2;\n        break;\n      case LineWidthType.BOLD:\n        Tool.lineWidthFactor = 3;\n        break;\n      case LineWidthType.MAXBOLD:\n        Tool.lineWidthFactor = 4;\n        break;\n      case LineWidthType.LINESIZE:\n        Tool.lineWidthFactor = lineSize;\n        break;\n      default:\n        break;\n    }\n  }, [lineWidthType, lineSize]);\n\n  useEffect(() => {\n    Tool.mainColor = mainColor;\n  }, [mainColor]);\n\n  useEffect(() => {\n    Tool.fillColor = fillColor;\n  }, [fillColor]);\n\n  useEffect(() => {\n    Tool.subColor = subColor;\n  }, [subColor]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      showCanvasCursor();\n      // drawCanvas();\n      Tool.ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n      // 注册清空画布事件\n      const dispatcher = dispatcherContext.dispatcher;\n      const callback = () => {\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n          if (imgSrc) {\n            const img = new Image();\n            img.crossOrigin = \"anonymous\";\n            img.src = imgSrc;\n            img.onload = function () {\n              const { width, height } = img;\n              /*1.在canvas 中绘制图像*/\n              ctx.drawImage(img, 0, 0);\n              /*2.从canvas 中获取图像的ImageData*/\n              const imgData = ctx.getImageData(0, 0, width, height);\n              /*3.在canvas 中显示ImageData*/\n              ctx.putImageData(\n                imgData,\n                //位置\n                0,\n                height\n              );\n              snapshot.add(imgData);\n            };\n          } else {\n            ctx.fillStyle = \"#2d2d2d\";\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n          }\n        }\n      };\n      dispatcher.on(CLEAR_EVENT, callback);\n\n      // 注册画布前进事件\n      const forward = () => {\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n          const imageData = snapshot.forward();\n          if (imageData) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.putImageData(imageData, 0, 0);\n          }\n        }\n      };\n      dispatcher.on(REDO_EVENT, forward);\n\n      // 注册画布后退事件\n      const back = () => {\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n          const imageData = snapshot.back();\n          if (imageData) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.putImageData(imageData, 0, 0);\n          }\n        }\n      };\n      dispatcher.on(UNDO_EVENT, back);\n\n      return () => {\n        dispatcher.off(CLEAR_EVENT, callback);\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(() => {\n    showCanvasCursor();\n  }, [strawType]);\n\n  //鼠标icon\n  const showCanvasCursor = () => {\n    const canvas = canvasRef.current;\n    const textBox: any = textBoxRef.current;\n    const showText = textBox?.resizableTextArea?.textArea;\n    if (text) {\n      setText(\"\");\n    }\n    if (canvas) {\n      if (strawType) {\n        //吸色\n        return (canvas.style.cursor = `url(${straw}) 12 16,auto`);\n      }\n      if (toolType === 0) {\n        canvas.style.cursor = `url(${cursorPen}) 12 16,auto`;\n      } else if (toolType === 4) {\n        canvas.style.cursor = `url(${cursorErase}) 12 16,auto`;\n      } else if (toolType === 1) {\n        canvas.style.cursor = `url(${bucket}) 12 16,auto`;\n      } else {\n        canvas.style.cursor = `auto`;\n      }\n      if (toolType !== 2 && textBox && showText) {\n        showText!.setAttribute(\"style\", `z-index:-1;display:none`);\n      }\n    }\n  };\n\n  const drawCanvas = () => {\n    const canvas = canvasRef.current;\n    const container = allCanvasRef!.current;\n    const textRef = canvasTextRef.current;\n    if (canvas && container && textRef) {\n      const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n      if (imgSrc) {\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.src = imgSrc;\n        img.onload = function () {\n          canvas.height = img.height;\n          canvas.width = img.width;\n          /*1.在canvas 中绘制图像*/\n          // ctx.scale(showScale, showScale);\n          textRef.setAttribute(\n            \"style\",\n            `width:${canvas.width};height:${canvas.height}`\n          );\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n          snapshot.add(ctx.getImageData(0, 0, canvas.width, canvas.height));\n        };\n      } else if (CanvasSize) {\n        canvas.height = CanvasSize.height;\n        canvas.width = CanvasSize.width;\n        ctx.fillStyle = background || \"#2d2d2d\";\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        snapshot.add(ctx.getImageData(0, 0, canvas.width, canvas.height));\n      }\n    }\n  };\n\n  useEffect(() => {\n    const container = allCanvasRef!.current;\n    const canvas = canvasRef.current;\n\n    if (CanvasSize && container && canvas) {\n      if (Tool.ctx) {\n        Tool.ctx.clearRect(0, 0, canvas.width, canvas?.height);\n      }\n      drawCanvas();\n      const height = container!.clientHeight;\n      const width = container!.clientWidth;\n      const showScale =\n        Math.min(width, height) /\n          Math.max(CanvasSize.height, CanvasSize.width) || 1;\n      show_scale = showScale; //getScale({ width, height }, CanvasSize);\n      Tool.currentScale = show_scale;\n      translatex = (width - CanvasSize.width * show_scale) / 2 / show_scale;\n      translatey = (height - CanvasSize.height * show_scale) / 2;\n      Tool.translate = {\n        translatex,\n        translatey,\n      };\n      canvas.style.transform = `scale(${show_scale}) translate(${translatex}px,${translatey}px)`;\n      //canvas.style.transform = `translate(${translatex}px,${translatey}px)`;\n    }\n  }, [CanvasSize]);\n\n  const onMouseDown = (event: MouseEvent) => {\n    // if (text) {\n    //   setText(\"\");\n    // }\n    if (tool) {\n      tool.onMouseDown(event);\n    }\n  };\n\n  const onMouseUp = (event: MouseEvent) => {\n    if (text) {\n      setText(\"\");\n    }\n    if (tool) {\n      tool.onMouseUp(event);\n      // 存储canvas剪影\n      snapshot.add(\n        Tool.ctx.getImageData(\n          0,\n          0,\n          Tool.ctx.canvas.width,\n          Tool.ctx.canvas.height\n        )\n      );\n    }\n  };\n\n  const onTouchStart = (event: TouchEvent) => {\n    if (tool) {\n      tool.onTouchStart(event);\n    }\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    if (tool) {\n      tool.onTouchMove(event);\n    }\n  };\n\n  const onTouchEnd = (event: TouchEvent) => {\n    if (tool) {\n      tool.onTouchEnd(event);\n    }\n    // 存储canvas剪影\n    snapshot.add(\n      Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height)\n    );\n  };\n\n  const getTrans = (\n    client: number,\n    newScale: number,\n    direction: string,\n    img: any,\n    boxdom: any,\n    scale: number\n  ) => {\n    const lastTrans = direction === \"width\" ? translatex : translatey;\n    // console.log(\"已经偏移的距离:\", lastTrans);\n\n    const sizeChanage = img[direction] * newScale - img[direction] * scale;\n    // console.log(`img ${direction}放大了:`, sizeChanage);\n\n    // 整体已经移动过了，需要弥补回来\n    const pre = client - lastTrans - boxdom[direction === \"width\" ? \"x\" : \"y\"];\n\n    //console.log(\"缩放中心到边界的距离\", pre);\n\n    const percent = pre / (img[direction] * scale);\n\n    //  console.log(\"当前缩放尺度下，缩放中心到边界比例\", percent);\n\n    const trans = percent * sizeChanage;\n    // console.log(\"缩放中心移动的距离:\", trans);\n    return trans;\n  };\n\n  const onMousewheel = (event: WheelEvent) => {\n    event.preventDefault();\n    if (toolType === ToolType.TEXT) {\n      return;\n    }\n    const canvas = canvasRef.current;\n    const container = allCanvasRef!.current;\n    const { clientX, clientY, deltaX, deltaY, ctrlKey } = event;\n    const { width, height, x, y } = container!.getBoundingClientRect();\n    const { width: canvasWidth, height: canvasHeight } =\n      container!.getBoundingClientRect();\n    let newScale;\n    if (ctrlKey) {\n      //双指放大缩小\n      if (deltaY < 0) {\n        newScale = show_scale + scaleStep;\n        newScale = Math.min(newScale, maxScale);\n      } else {\n        newScale = show_scale - scaleStep;\n        newScale = Math.max(newScale, minScale);\n      }\n      const transX = getTrans(\n        clientX,\n        newScale,\n        \"width\",\n        CanvasSize,\n        {\n          width,\n          height,\n          x,\n          y,\n        },\n        show_scale\n      );\n      const transY = getTrans(\n        clientY,\n        newScale,\n        \"height\",\n        CanvasSize,\n        {\n          width,\n          height,\n          x,\n          y,\n        },\n        show_scale\n      );\n      translatex = translatex - transX;\n      translatey = translatey - transY;\n      show_scale = newScale;\n      Tool.currentScale = newScale;\n      Tool.translate = {\n        translatex,\n        translatey,\n      };\n      canvas!.style.transform = `translate3d(${translatex}px, ${translatey}px, 0px) scale(${show_scale})`;\n    }\n    // else {\n    //   if (!!deltaX && !deltaY) {\n    //     // if (translatex > 0 && translatex < width) {\n    //     // 左右移动 向右 -deltaX < 0  向左   >0\n    //     translatex = Number((translatex - deltaX).toFixed(3));\n    //     // }\n    //   } else if (!!deltaY && !deltaX) {\n    //     // if (translatey > 0 && translatex < height) {\n    //     // 左右移动 向右 -deltaX < 0  向左   >0\n    //     translatey = Number((translatey - deltaY).toFixed(3));\n    //     // }\n    //   }\n    // }\n  };\n\n  const onCanvasBoxWheel = (event: WheelEvent) => {\n    const { clientX, clientY, deltaX, deltaY, ctrlKey } = event;\n    event.preventDefault();\n    if (toolType === ToolType.TEXT) {\n      return;\n    }\n    const canvas = canvasRef.current;\n    if (!ctrlKey) {\n      if (!!deltaX && !deltaY) {\n        // if (translatex > 0 && translatex < width) {\n        // 左右移动 向右 -deltaX < 0  向左   >0\n        translatex = Number((translatex - deltaX).toFixed(3));\n        // }\n      } else if (!!deltaY && !deltaX) {\n        // if (translatey > 0 && translatex < height) {\n        // 左右移动 向右 -deltaX < 0  向左   >0\n        translatey = Number((translatey - deltaY).toFixed(3));\n        // }\n      }\n      Tool.translate = {\n        translatex,\n        translatey,\n      };\n      canvas!.style.transform = `translate(${translatex}px, ${translatey}px) scale(${show_scale})`;\n    }\n  };\n\n  const onKeyDown = (e: KeyboardEvent) => {\n    if (tool) {\n      tool.onKeyDown(e);\n    }\n  };\n\n  const onMouseMove = (event: MouseEvent) => {\n    if (tool) {\n      tool.onMouseMove(event);\n    }\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    // const textBox = textBoxRef.current;\n    const canvasBox = allCanvasRef.current;\n    if (canvas && canvasBox) {\n      canvas.addEventListener(\"mousedown\", onMouseDown);\n      canvas.addEventListener(\"mousemove\", onMouseMove);\n      canvas.addEventListener(\"mouseup\", onMouseUp);\n      canvas.addEventListener(\"wheel\", onMousewheel, { passive: false });\n      canvas.addEventListener(\"touchstart\", onTouchStart);\n      canvas.addEventListener(\"touchmove\", onTouchMove);\n      canvas.addEventListener(\"touchend\", onTouchEnd);\n      window.addEventListener(\"keydown\", onKeyDown);\n      // textBox.addEventListener(\"keydown\", onKeyDown);\n      canvasBox.addEventListener(\"wheel\", onCanvasBoxWheel, { passive: false });\n\n      return () => {\n        canvas.removeEventListener(\"mousedown\", onMouseDown);\n        canvas.removeEventListener(\"mousemove\", onMouseMove);\n        canvas.removeEventListener(\"mouseup\", onMouseUp);\n        canvas.removeEventListener(\"wheel\", onMousewheel);\n\n        canvas.removeEventListener(\"touchstart\", onTouchStart);\n        canvas.removeEventListener(\"touchmove\", onTouchMove);\n        canvas.removeEventListener(\"touchend\", onTouchEnd);\n        // textBox.removeEventListener(\"keydown\", onKeyDown);\n\n        canvasBox.removeEventListener(\"wheel\", onCanvasBoxWheel);\n      };\n    }\n  }, [canvasRef, onMouseDown, onMouseMove, onMouseUp]);\n\n  const style = {\n    margin: \"auto\",\n  };\n  if (allCanvasRef && CanvasSize) {\n    const allCanvas = allCanvasRef.current;\n    if (allCanvas) {\n      style.margin =\n        allCanvas.offsetWidth < (CanvasSize?.width || 0) ? \"unset\" : \"auto\";\n    }\n  }\n  return (\n    <div className=\"all-canvas\" ref={allCanvasRef} id=\"all-canvas\">\n      <canvas\n        id={`ccc-paint-canvas ${id}`}\n        className=\"ccc-paint-canvas\"\n        ref={canvasRef}\n        style={{\n          background: background,\n          ...style,\n        }}\n      ></canvas>\n      <div className=\"canvas-text\" id=\"text-container\" ref={canvasTextRef}>\n        <TextArea\n          id=\"textBox\"\n          ref={textBoxRef}\n          autoSize={true}\n          size={\"small\"}\n          name=\"story\"\n          value={text}\n          onChange={(e) => setText(e.target.value)}\n          className={`text-box`}\n          // rows={1}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Canvas;\n","/Users/jinmingliu/code/ccc-react-paint/src/left-tool/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/edit/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/components/loading/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/tool.ts",["305"],"/* eslint-disable @typescript-eslint/no-unused-vars */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n\n// 吸色功能\nexport const setStraw = (pos?: Point) => {\n  if (Tool.strawFlag && pos) {\n    // 吸色\n    const color = getPixelColorOnCanvas(Tool.ctx, pos.x, pos!.y);\n    Tool.strawColor = color;\n    Tool.strawFlag = false;\n  } \n \n};\n\n\nexport const getMousePos = (canvas: HTMLCanvasElement, event: MouseEvent|undefined, type?: string,pos?: Point): Point => {\n  const rect = canvas.getBoundingClientRect();\n  const scale = Tool.currentScale || 1\n  if (pos) { \n    return {\n      x: (pos.x - rect.left) / scale,\n      y: (pos.y - rect.top) / scale\n    //   x: (pos.x) / scale - Tool.translate.translatex,\n    // y: (pos.y )/scale -Tool.translate.translatey\n  };\n  }\n  if (event) { \n return {\n    x: (event.clientX - rect.left)/scale,\n    y: (event.clientY - rect.top)/scale\n  };\n  }\n  return {\n    x: 0,\n    y:0\n  }\n};\n\nexport const getTouchPos = (canvas: HTMLCanvasElement, event: TouchEvent): Point => {\n  return {\n    x: event.touches[0].pageX - canvas.offsetLeft,\n    y: event.touches[0].pageY - canvas.offsetTop\n  };\n};\n\nexport const rgbToHex = (r: number, g: number, b: number, a?: number) => {\n  const componentToHex = (c: number) => {\n    const hex = c.toString(16);\n    return hex.length == 1 ? \"0\" + hex : hex;\n  };\n\n  const res = \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n\n  return a ? res + componentToHex(a) : res;\n};\n\nexport const hexToRgb = (hex: string) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n        a: parseInt(result[4], 16)\n      }\n    : null;\n};\n\nexport const getPixelColorOnCanvas = (ctx: CanvasRenderingContext2D, x: number, y: number): string => {\n  const p = ctx.getImageData(x, y, 1, 1).data;\n  return rgbToHex(p[0], p[1], p[2], p[3]);\n};\n\nexport const updateImageData = (origin: ImageData, data: ImageData, fillData: [number, number, number, number]) => {\n  for (let row = 0; row < data.height; row++) {\n    for (let col = 0; col < data.width; col++) {\n      const index = row * data.width * 4 + col * 4;\n      const r1 = data.data[index];\n      const g1 = data.data[index + 1];\n      const b1 = data.data[index + 2];\n      const a1 = data.data[index + 3];\n\n      const r2 = origin.data[index];\n      const g2 = origin.data[index + 1];\n      const b2 = origin.data[index + 2];\n      const a2 = origin.data[index + 3];\n\n      const equalOrigin = r1 === r2 && g1 === g2 && b1 === b2 && a1 === a2;\n      const equalFilling = r1 === fillData[0] && g1 === fillData[1] && b1 === fillData[2] && a1 === fillData[3];\n      if (!(equalOrigin || equalFilling)) {\n        data.data[index] = fillData[0];\n        data.data[index + 1] = fillData[1];\n        data.data[index + 2] = fillData[2];\n        data.data[index + 3] = fillData[3];\n      }\n    }\n  }\n\n  return data;\n};\n\nexport const clacArea = (points: Point) => {\n  return Tool.showArea ? Tool.showArea.find(item => item[0] === points.x && item[1] === points.y):true\n}\n\nexport default class Tool {\n  /**\n   * 线宽\n   */\n  public static lineWidthFactor = 1;\n  /**\n   * 主色\n   */\n  public static fillColormainColor = \"black\";\n  /**\n   * 副色\n   */\n  public static subColor = \"white\";\n\n  // 吸色\n  public static strawColor ='';\n\n  // 背景色\n  public static fillColor = \"#2d2d2d\";\n\n  // textCanvas\n   public static textList: Record<string, any> = {};\n\n\n\n\n  public static zoom = {\n    scaleX:1,\n    scaleY:1\n  }\n  public currentScale = 1\n\n  public strawFlag = false\n\n  public static ctx: CanvasRenderingContext2D;\n  //可画区域\n  public static showArea: Array<[number, number]> | null;\n  static currentScale: number;\n  static show_offset: any;\n  static strawFlag: boolean;\n  static mainColor: string;\n  static translate: { translatex: number; translatey: number; };\n\n  public onMouseDown(event: MouseEvent): void {\n    //\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    //\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    //\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    //\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    //\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    //\n  }\n\n  public onKeyDown(event: KeyboardEvent): void { \n    //\n  }\n \n}\n","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/eraser.ts",["306"],"import { ColorType } from \"../toolType\";\nimport Tool, { Point, getMousePos, getPixelColorOnCanvas, getTouchPos, hexToRgb, updateImageData, clacArea } from \"./tool\";\nclass Eraser extends Tool {\n  protected lineWidthBase = 1;\n  private mouseDown = false;\n  private color = \"transparent\";\n  private saveImageData?: ImageData;\n  private previousPos: Point = {\n    x: 0,\n    y: 0\n  };\n  public constructor(lineSize:number) {\n    super();\n    this.lineWidthBase = lineSize;\n    this.color = \"transparent\";\n  }\n  private operateStart(pos: Point) {\n    if (!Tool.ctx) return;\n    this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    this.mouseDown = true;\n    this.color = getPixelColorOnCanvas(Tool.ctx, pos.x - 2, pos.y - 2);\n    Tool.ctx.lineWidth = this.lineWidthBase;\n    Tool.ctx.strokeStyle = this.color;\n    Tool.ctx.lineJoin = \"round\";\n    Tool.ctx.lineCap = \"round\";\n    Tool.ctx.beginPath();\n    this.previousPos = pos;\n  }\n  private operateMove(pos: Point) {\n    if (this.mouseDown) {\n      Tool.ctx.moveTo(this.previousPos.x, this.previousPos.y);\n      const c = 0.5 * (this.previousPos.x + pos.x);\n      const d = 0.5 * (this.previousPos.y + pos.y);\n      Tool.ctx.quadraticCurveTo(c, d, pos.x, pos.y);\n      Tool.ctx.stroke();\n      this.previousPos = pos;\n    }\n  }\n  private operateEnd() {\n    if (this.mouseDown) {\n      Tool.ctx.closePath();\n      this.mouseDown = false;\n      let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n      const colorRgb = hexToRgb(this.color);\n      if (colorRgb && this.saveImageData) {\n        imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, colorRgb.a]);\n        Tool.ctx.putImageData(imageData, 0, 0);\n      }\n    }\n  }\n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n\n      if (clacArea(mousePos)) { \n    this.operateStart(mousePos);\n    }\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    event.preventDefault();\n    this.operateEnd();\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    this.operateMove(mousePos);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchPos);\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateMove(touchPos);\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this.operateEnd();\n  }\n}\n\nexport default Eraser;\n","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorExtract.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorFill.ts",["307"],"import Tool, { getMousePos, getTouchPos,setStraw, Point } from \"./tool\";\nimport Color from \"color\";\nimport { parseColorString } from \"../colorChange\";\n\n/**\n * 高效率的填充算法\n * 参考地址: http://www.williammalone.com/articles/html5-canvas-javascript-paint-bucket-tool/\n */\nconst efficentFloodFill = (\n  ctx: CanvasRenderingContext2D,\n  startX: number,\n  startY: number,\n  fillColor: number[]\n) => {\n  // 保证 startX 和 startY 是正整数\n  // 经测试，在触屏设备中 startX 和 startY 可能是小数，造成填充功能无法正确填充\n  startX = Math.round(startX);\n  startY = Math.round(startY);\n  const pixelStack: [number, number][] = [\n    [Math.round(startX), Math.round(startY)],\n  ];\n  const canvasWidth = ctx.canvas.width,\n  canvasHeight = ctx.canvas.height;\n  const startPos = (startY * canvasWidth + startX) * 4;\n  const colorLayer = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n  const startColor: number[]= [\n    colorLayer.data[startPos],\n    colorLayer.data[startPos + 1],\n    colorLayer.data[startPos + 2],\n    colorLayer.data[startPos + 3],\n  ];\n  const updatedPoint: Record<string | number, boolean> = {};\n\n  if (\n    startColor[0] === fillColor[0] &&\n    startColor[1] === fillColor[1] &&\n    startColor[2] === fillColor[2] && \n    startColor[3] === fillColor[3]\n  )\n    return;\n  //const newData = [];\n  while (pixelStack.length > 0) {\n    const newPos = pixelStack.pop() as [number, number];\n    const x = newPos[0];\n    let y = newPos[1];\n    let pixelPos = (y * canvasWidth + x) * 4;\n    while (y-- >= 0 && matchColor(colorLayer, pixelPos, startColor)) {\n      pixelPos -= canvasWidth * 4;\n    }\n    pixelPos += canvasWidth * 4;\n    ++y;\n    let reachLeft = false,\n      reachRight = false;\n\n    if (updatedPoint[pixelPos]) {\n      continue;\n    }\n    updatedPoint[pixelPos] = true\n    while (\n      y++ < canvasHeight - 1 &&\n      matchColor(colorLayer, pixelPos, startColor)\n    ) {\n      fillPixel(colorLayer, pixelPos, fillColor);\n      if (x > 0) {\n        if (matchColor(colorLayer, pixelPos - 4, startColor)) {\n          if (!reachLeft) {\n            pixelStack.push([x - 1, y]);\n            reachLeft = true;\n          }\n        } else if (reachLeft) {\n          reachLeft = false;\n        }\n      }\n\n      if (x < canvasWidth - 1) {\n        if (matchColor(colorLayer, pixelPos + 4, startColor)) {\n          if (!reachRight) {\n            pixelStack.push([x + 1, y]);\n            reachRight = true;\n          }\n        } else if (reachRight) {\n          reachRight = false;\n        }\n      }\n\n      pixelPos += canvasWidth * 4;\n    }\n  }\n  ctx.putImageData(colorLayer, 0, 0);\n};\n\n/**\n * 判断两个位置的像素颜色是否相同\n */\nconst matchColor = (\n  colorLayer: ImageData,\n  pixelPos: number,\n  color: number[],\n) => {\n  const r = colorLayer.data[pixelPos];\n  const g = colorLayer.data[pixelPos + 1];\n  const b = colorLayer.data[pixelPos + 2];\n \n  return (\n    Math.abs(r - color[0]) < 30 &&\n    Math.abs(g - color[1]) < 30 &&\n    Math.abs(b - color[2]) < 30\n  );\n};\n\n/**\n * 修改指定ImageData的指定位置像素颜色\n */\nconst fillPixel = (\n  colorLayer: ImageData,\n  pixelPos: number,\n  color:number[]| [number, number, number,number]\n) => {\n  \n  colorLayer.data[pixelPos] = color[0];\n  colorLayer.data[pixelPos + 1] = color[1];\n  colorLayer.data[pixelPos + 2] = color[2];\n  colorLayer.data[pixelPos + 3] = color[3]\n  return colorLayer;\n};\n\nclass ColorFill extends Tool {\n  mouseDownTimer: any;\n  private operateStart(pos: Point) {\n    const showColor = parseColorString(Tool.strawColor || Tool.fillColor ||\"#000000FF\")\n    console.time(\"efficentFloodFill\");\n    const colorArr: number[] = [showColor.r, showColor.g, showColor.b, showColor.a * 255]\n    Promise.resolve().then(() => { \n      efficentFloodFill(Tool.ctx, pos.x, pos.y, colorArr);\n    })\n    console.timeEnd(\"efficentFloodFill\");\n  }\n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n    if(this.mouseDownTimer) return \n    const mousepos = getMousePos(Tool.ctx.canvas, event);\n    setStraw(mousepos);\n    this.operateStart(mousepos);\n\n    this.mouseDownTimer = setTimeout(() => {\n      clearTimeout(this.mouseDownTimer);\n      this.mouseDownTimer = undefined;\n    }, 300);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchpos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchpos);\n  }\n}\n\nexport default ColorFill;\n","/Users/jinmingliu/code/ccc-react-paint/src/util/tool/pen.ts",["308","309"],"import { ColorType } from \"../toolType\";\nimport { hexToRgba, } from \"../colorChange\";\nimport Tool, { Point, getMousePos, setStraw, getTouchPos, hexToRgb,clacArea, updateImageData } from \"./tool\";\n\nclass Pen extends Tool {\n  protected lineWidthBase = 1;\n  protected drawColorType = ColorType.MAIN;\n  protected eraser = \"\";\n  private mouseDown = false;\n  private saveImageData?: ImageData;\n  private previousPos: Point = {\n    x: 0,\n    y: 0\n  };\n  private operateStart(pos: Point) {\n    if (!Tool.ctx) return;\n    setStraw(pos);\n    this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    this.mouseDown = true;\n    const showColor = Tool.strawColor\n      ? Tool.strawColor\n      : this.drawColorType === ColorType.MAIN\n      ? Tool.mainColor\n        : Tool.subColor;\n    const testColor = hexToRgba(showColor)\n    Tool.ctx.lineWidth = Tool.lineWidthFactor * this.lineWidthBase;\n    Tool.ctx.strokeStyle = testColor;\n    Tool.ctx.lineJoin = \"round\";\n    Tool.ctx.lineCap = \"round\";\n    Tool.ctx.beginPath();\n    this.previousPos = pos;\n  }\n  private operateMove(pos: Point) {\n    if (this.mouseDown) {\n      Tool.ctx.moveTo(this.previousPos.x, this.previousPos.y);\n      const c = 0.5 * (this.previousPos.x + pos.x);\n      const d = 0.5 * (this.previousPos.y + pos.y);\n      Tool.ctx.quadraticCurveTo(c, d, pos.x, pos.y);\n      Tool.ctx.stroke();\n      this.previousPos = pos;\n    }\n  }\n  private operateEnd() {\n    if (this.mouseDown) {\n      Tool.ctx.closePath();\n      this.mouseDown = false;\n    //  let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    //    const showColor = Tool.strawColor\n    //   ? Tool.strawColor\n    //   : this.drawColorType === ColorType.MAIN\n    //   ? Tool.mainColor\n    //        : Tool.subColor;\n    //       const testColor = hexToRgba(showColor)\n    // const rgbaColor = parseColorString(testColor)\n    //   const colorRgb = hexToRgb(showColor);\n    //   if (colorRgb && this.saveImageData) {\n    //     imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, 0.5]);\n    //     Tool.ctx.putImageData(imageData, 0, 0);\n    //   }\n    }\n  }\n  \n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    \n    if (clacArea(mousePos)) { \n    this.operateStart(mousePos);\n    }\n\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    event.preventDefault();\n    this.operateEnd();\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    this.operateMove(mousePos);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchPos);\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateMove(touchPos);\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this.operateEnd();\n  }\n}\n\nexport default Pen;\n","/Users/jinmingliu/code/ccc-react-paint/src/util/dispatcher/event.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/shape.ts",["310","311"],"import {ShapeToolType} from \"../toolType\";\nimport Tool, {Point, getMousePos, getTouchPos,setStraw, hexToRgb,clacArea, updateImageData} from \"./tool\";\n\n/**\n * 根据形状类型，获取要绘制的形状的顶点(圆形，返回圆心)\n * @param type shape type\n * @param sx x coord of start\n * @param sy y coord of start\n * @param ex x coord of end\n * @param ey y coord of end\n */\nconst getVertexs = (type: ShapeToolType, sx: number, sy: number, ex: number, ey: number): Point[] => {\n    const points: Point[] = [];\n    const mx = 0.5 * (sx + ex), my = 0.5 * (sy + ey);\n\n    switch (type) {\n        case ShapeToolType.LINE:\n            points.push({x: sx, y: sy});\n            points.push({x: ex, y: ey});\n            break;\n        case ShapeToolType.RECT:\n            points.push({x: sx, y: sy});\n            points.push({x: ex, y: sy});\n            points.push({x: ex, y: ey});\n            points.push({x: sx, y: ey});\n            break;\n        case ShapeToolType.CIRCLE:\n            points.push({x: 0.5 * (sx + ex), y: 0.5 * (sy + ey)});\n            break;\n        case ShapeToolType.RHOMBUS:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.TRIANGLE:\n            points.push({x: mx, y: sy});\n            points.push({x: sx, y: ey});\n            points.push({x: ex, y: ey});\n            break;\n        case ShapeToolType.PENTAGON:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: 0.5 * (mx + ex), y: ey});\n            points.push({x: 0.5 * (mx + sx), y: ey});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.SEXANGLE:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: 0.5 * (sy + my)});\n            points.push({x: ex, y: 0.5 * (ey + my)});\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: 0.5 * (ey + my)});\n            points.push({x: sx, y: 0.5 * (sy + my)});\n            break;\n        case ShapeToolType.ARROW_TOP:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: my});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: ey});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: ey});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: my});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.ARROW_RIGHT:\n            points.push({x: ex, y: my});\n            points.push({x: mx, y: ey});\n            points.push({x: mx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: sx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: sx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: sy});\n            break;\n        case ShapeToolType.ARROW_DOWN:\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: my});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: my});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: sy});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: sy});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: my});\n            points.push({x: ex, y: my});\n            break;\n        case ShapeToolType.ARROW_LEFT:\n            points.push({x: sx, y: my});\n            points.push({x: mx, y: sy});\n            points.push({x: mx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: ex, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: ex, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: ey});\n            break;\n        case ShapeToolType.FOUR_STAR:\n            const offsetX = 0.125 * (ex - sx), offsetY = 0.125 * (ey - sy);\n            points.push({x: mx, y: sy});\n            points.push({x: mx + offsetX, y: my - offsetY});\n            points.push({x: ex, y: my});\n            points.push({x: mx + offsetX, y: my + offsetY});\n            points.push({x: mx, y: ey});\n            points.push({x: mx - offsetX, y: my + offsetY});\n            points.push({x: sx, y: my});\n            points.push({x: mx - offsetX, y: my - offsetY});\n            break;\n        default:\n            break;\n    }\n    return points;\n};\n\nclass Shape extends Tool {\n    private type: ShapeToolType;\n    private saveImageData?: ImageData;\n    private isMouseDown = false;\n    private mouseDownPos = {x: 0, y: 0};\n    private lineWidthBase = 1;\n    public isDashed = false;\n    private dashLineStyle = [10, 10];\n    static shapeWidth: any;\n    public constructor(type: ShapeToolType, dashed = false) {\n        super();\n        this.type = type;\n        this.isDashed = dashed;\n    }\n\n    public setType(type: ShapeToolType) {\n        this.type = type;\n    }\n\n    private operateStart(pos: { x: number; y: number }) {\n        setStraw(pos)\n        this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n        this.isMouseDown = true;\n        this.mouseDownPos = pos;\n        Tool.ctx.strokeStyle = Tool.mainColor;\n        Tool.ctx.lineWidth = Shape.shapeWidth;//5// Tool.lineWidthFactor * this.lineWidthBase;\n        Tool.ctx.fillStyle = Tool.subColor;\n        if (this.isDashed) {\n            Tool.ctx.setLineDash(this.dashLineStyle);\n        }\n    }\n\n    private operateMove(pos: {x: number; y: number}) {\n        if (this.isMouseDown && this.saveImageData) {\n            const ctx = Tool.ctx;\n            ctx.clearRect(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n\n            ctx.putImageData(this.saveImageData, 0, 0);\n            const vertexs: Point[] = getVertexs(this.type, this.mouseDownPos.x, this.mouseDownPos.y, pos.x, pos.y);\n\n            if (this.type === ShapeToolType.CIRCLE) {\n                ctx.beginPath();\n                ctx.ellipse(vertexs[0].x, vertexs[0].y, Math.abs(0.5 * (pos.x - this.mouseDownPos.x)), Math.abs(0.5 * (pos.y - this.mouseDownPos.y)), 0, 0, Math.PI * 2);\n                ctx.stroke();\n            } else {\n                ctx.beginPath();\n                ctx.moveTo(vertexs[0].x, vertexs[0].y);\n                for (let i = 1; i < vertexs.length; i++) {\n                    ctx.lineTo(vertexs[i].x, vertexs[i].y);\n                }\n                ctx.closePath();\n                ctx.stroke();\n            }\n        }\n    }\n    \n    private operateEnd() {\n        Tool.ctx.setLineDash([]);\n        // let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n        // const colorRgb = hexToRgb(Tool.mainColor);\n        // if (colorRgb && this.saveImageData) {\n        //     imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, colorRgb.a]);\n\n        //     Tool.ctx.putImageData(imageData, 0, 0);\n        // }\n        \n        this.isMouseDown = false;\n        this.saveImageData = undefined;\n    }\n\n    public onMouseDown(event: MouseEvent): void {\n        event.preventDefault();\n        const mousePos = getMousePos(Tool.ctx.canvas, event);\n          if (clacArea(mousePos)) { \n            this.operateStart(mousePos);\n          }\n    }\n\n    public onMouseMove(event: MouseEvent): void {\n        event.preventDefault();\n        const mousePos = getMousePos(Tool.ctx.canvas, event);\n        this.operateMove(mousePos);\n    }\n\n    public onMouseUp(event: MouseEvent): void {\n        event.preventDefault();\n        this.operateEnd();\n    }\n\n    public onTouchStart(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        const canvas = event.target as HTMLCanvasElement;\n        const touchPos = getTouchPos(canvas, event);\n\n        this.operateStart(touchPos);\n    }\n\n    public onTouchMove(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        const canvas = event.target as HTMLCanvasElement;\n        const touchPos = getTouchPos(canvas, event);\n\n        this.operateMove(touchPos);\n    }\n\n    public onTouchEnd(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        this.operateEnd();\n    }\n}\n\nexport default Shape;\n","/Users/jinmingliu/code/ccc-react-paint/src/ToolTypeIcon.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/snapshot/index.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/pen/index.tsx",["312","313"],"import React, { FC } from \"react\";\nimport { useContext } from \"react\";\nimport { LineWidthContext } from \"@/context\";\nimport IntegerStep from \"../components/slider\";\nimport ColorPanel from \"../components/colorPanel\";\nimport \"./index.less\";\nimport { Tool } from \"../../util/tool\";\n\ninterface PenType {\n  lineSize: number;\n  maxSize: number;\n}\n\nconst ShowPen = (props: PenType) => {\n  const lineWidthContext = useContext(LineWidthContext);\n\n  const { lineSize, maxSize } = props;\n  return (\n    <div className=\"ccc-pen\">\n      <div className=\"ccc-slider-item\">\n        <h3>Brush Thickness</h3>\n        <IntegerStep\n          min={1}\n          max={maxSize}\n          value={lineSize}\n          onPropsChange={(value) => {\n            lineWidthContext.setLineSize(value);\n          }}\n        />\n      </div>\n      <ColorPanel type=\"pen\" className=\"toolbar-item\" />\n    </div>\n  );\n};\n\nexport default ShowPen;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/showShape/index.tsx",["314","315"],"import React, { FC, useEffect } from \"react\";\nimport ShapeComponent from \"../components/shape\";\nimport ColorPanel from \"../components/colorPanel\";\nimport { DownOutlined } from \"@ant-design/icons\";\nimport IntegerStep from \"../components/slider\";\nimport { Shape } from \"../../util/tool\";\nimport arrow from \"@/icon/arrow.svg\";\nimport \"./index.less\";\n\ninterface shapeType {\n  lineSize: number;\n  maxSize: number;\n}\n\nconst showShape = (props: shapeType) => {\n  const { lineSize, maxSize } = props;\n\n  useEffect(() => {\n    Shape.shapeWidth = lineSize / 2;\n  }, []);\n  return (\n    <div className=\"ccc-shape\">\n      <div className=\"ccc-shape-item\">\n        <h3>Shape Thickness</h3>\n        <IntegerStep\n          min={1}\n          max={Math.floor(maxSize / 2)}\n          value={Shape.shapeWidth || lineSize / 2}\n          onPropsChange={(value) => {\n            Shape.shapeWidth = value;\n          }}\n        />\n      </div>\n      <h3 className=\"ccc-shape-title\">\n        <span>Shapes</span>\n        <img src={arrow}></img>\n      </h3>\n      <ShapeComponent className=\"toolbar-item\" />\n      <ColorPanel className=\"toolbar-item\" />\n    </div>\n  );\n};\n\nexport default showShape;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/formatColor/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/text/index.tsx",["316"],"/Users/jinmingliu/code/ccc-react-paint/src/right/earser/index.tsx",["317"],"import React, { FC } from \"react\";\nimport { useContext } from \"react\";\nimport { LineWidthContext } from \"@/context\";\nimport IntegerStep from \"../components/slider\";\nimport \"./index.less\";\n\ninterface earserType {\n  lineSize: number;\n  maxSize: number;\n}\n\nconst Eraser = (props: earserType) => {\n  const { lineSize, maxSize } = props;\n  const lineWidthContext = useContext(LineWidthContext);\n\n  return (\n    <div className=\"ccc-pen\">\n      <div className=\"ccc-slider-item\">\n        <h3>Eraser Thickness</h3>\n        <IntegerStep\n          min={1}\n          max={maxSize}\n          value={lineSize}\n          onPropsChange={(value) => {\n            lineWidthContext.setLineSize(value);\n          }}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Eraser;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/components/colorPanel/index.tsx",["318"],"import React from \"react\";\nimport { useContext } from \"react\";\nimport { ColorContext, ToolTypeContext } from \"@/context\";\nimport { Tool } from \"../../../util/tool\";\nimport \"./index.less\";\nimport { useState } from \"react\";\nimport { useEffect } from \"react\";\nimport { SketchPicker } from \"react-color\";\nimport { getRandomColor } from \"../../../utils\";\nimport { strawIcon } from \"../../../ToolTypeIcon\";\nimport { toHexString } from \"../../../util/colorChange\";\n\ninterface ColorPanelProps {\n  className?: string;\n  testTool?: Tool;\n  color?: string;\n  type?: string;\n  onChange?: (color: string) => void;\n}\n\nconst activeColorTypeCls = \"active-color-type\";\n\nconst ColorPanel: React.FC<ColorPanelProps> = (props) => {\n  const { className, type, color, onChange, testTool } = props;\n  const colorStr = type === \"pen\" ? getRandomColor() : color || \"#000000FF\";\n  const [showColor, setColor] = useState(colorStr);\n  const colorContext = useContext(ColorContext);\n  const ToolContext = useContext(ToolTypeContext);\n\n  useEffect(() => {\n    colorContext.setColor(showColor);\n  }, [showColor, testTool]);\n\n  const getStrawColor = () => {\n    const startTime = new Date().getTime();\n    const intervalId = setInterval(function () {\n      const endTime = new Date().getTime();\n      if (Math.abs(endTime - startTime) >= 10 * 60 * 1000) {\n        clearInterval(intervalId); //清除定时器 ,超过10分钟没有吸色功能 清楚定时器\n        ToolContext.setStrawType(false);\n      }\n      if (Tool.strawColor) {\n        setColor(Tool.strawColor);\n        ToolContext.setStrawType(false);\n        clearInterval(intervalId); //清除定时器\n      }\n    }, 200);\n  };\n\n  const handleChange = (color: any) => {\n    if (Tool.strawColor !== \"\") {\n      Tool.strawColor = \"\";\n    }\n    const hexColor: string = toHexString(color.rgb);\n    setColor(hexColor);\n    Tool.strawColor = \"\";\n    // Tool.colorPicker = \"\";\n    if (onChange) {\n      onChange(hexColor);\n    }\n  };\n\n  useEffect(() => {\n    const nodeColor = document.getElementsByClassName(\n      \"ccc-paint-colorBox-picker\"\n    )[0];\n    const fileList = nodeColor?.getElementsByClassName(\"flexbox-fix\");\n    if (fileList[0]) {\n      fileList[0].setAttribute(\"style\", \"padding-left:12%;display: flex\");\n    }\n  }, []);\n\n  return (\n    <div className={className ? `colorpanel ${className}` : \"colorpanel\"}>\n      <div className=\"content\">\n        <h3>Color</h3>\n        <div className=\"material-color-box\">\n          <SketchPicker\n            className=\"ccc-paint-colorBox-picker\"\n            width=\"100%\"\n            disableAlpha={false}\n            color={showColor}\n            onChange={handleChange}\n          />\n          {/* {type !== \"text\" && ( */}\n          <span\n            className={`straw-color ${Tool.strawFlag ? \"select-item\" : \"\"}`}\n            onClick={() => {\n              Tool.strawFlag = true;\n              Tool.strawColor = \"\";\n              ToolContext.setStrawType(true);\n              getStrawColor();\n            }}\n          >\n            {strawIcon}\n          </span>\n          {/* )} */}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ColorPanel;\n","/Users/jinmingliu/code/ccc-react-paint/src/right/components/slider/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/right/components/shape/index.tsx",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/Text.ts",["319","320","321","322","323","324"],"/Users/jinmingliu/code/ccc-react-paint/src/util/colorChange.ts",[],"/Users/jinmingliu/code/ccc-react-paint/src/util/tool/colorChange.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/CCCPaint.tsx",["325","326","327","328"],"/Users/jinmingliu/work/ccc-react-paint/src/util/toolType.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/tool/tool.ts",["329","330"],"/Users/jinmingliu/work/ccc-react-paint/src/utils.tsx",[],"/Users/jinmingliu/work/ccc-react-paint/src/context/index.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/dispatcher/index.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/tool/index.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/left-tool/index.tsx",["331"],"import React from \"react\";\nimport { ToolType } from \"../util/toolType\";\nimport { ToolTypeContext } from \"@/context\";\nimport \"./index.less\";\nimport {\n  toolPen,\n  toolShape,\n  formatColor,\n  textIcon,\n  toolEraser,\n} from \"../ToolTypeIcon\";\nconst selectedToolClass = \"selected-tool\";\n\nexport interface ToolPanelProps {\n  className?: string;\n  fillColor?: string;\n  isPixel: boolean;\n}\n\nconst ToolPanel: React.FC<ToolPanelProps> = (props) => {\n  const { className, fillColor, isPixel } = props;\n  return (\n    <div className={className ? `toolpanel ${className}` : \"toolpanel\"}>\n      <ToolTypeContext.Consumer>\n        {({ type, setType }) => (\n          <>\n            <span title=\"Pencil Tool\" className=\"tool-Icon\">\n              <span\n                className={\n                  type === ToolType.PEN\n                    ? `tool-item ${selectedToolClass}`\n                    : \"tool-item\"\n                }\n                onClick={() => {\n                  setType(ToolType.PEN);\n                }}\n              >\n                {toolPen}\n              </span>\n            </span>\n            {/* <span title=\"Draw Shape\" className=\"tool-Icon\">\n              <span\n                className={\n                  type === ToolType.SHAPE\n                    ? `tool-item ${selectedToolClass}`\n                    : \"tool-item\"\n                }\n                onClick={() => {\n                  setType(ToolType.SHAPE);\n                }}\n              >\n                {toolShape}\n              </span>\n            </span> */}\n            <span title=\"Eraser Tool\" className=\"tool-Icon\">\n              <span\n                className={\n                  type === ToolType.ERASER\n                    ? `tool-item ${selectedToolClass}`\n                    : \"tool-item\"\n                }\n                onClick={() => {\n                  setType(ToolType.ERASER);\n                }}\n              >\n                {toolEraser}\n              </span>\n            </span>\n            <span title=\"Paint Bucket Tool\" className=\"tool-Icon\">\n              <span\n                className={\n                  type === ToolType.COLOR_FILL\n                    ? `tool-item color-tool ${selectedToolClass}`\n                    : \"tool-item color-tool\"\n                }\n                onClick={() => {\n                  setType(ToolType.COLOR_FILL);\n                }}\n              >\n                {formatColor}\n                <span\n                  className=\"bgColorIcon\"\n                  style={{\n                    background: type === ToolType.COLOR_FILL ? fillColor : \"\",\n                  }}\n                />\n              </span>\n            </span>\n            {!isPixel && (\n              <span title=\"Text\" className=\"tool-Icon\">\n                <span\n                  className={\n                    type === ToolType.TEXT\n                      ? `tool-item ${selectedToolClass}`\n                      : \"tool-item\"\n                  }\n                  onClick={() => {\n                    setType(ToolType.TEXT);\n                  }}\n                >\n                  {textIcon}\n                </span>\n              </span>\n            )}\n          </>\n        )}\n      </ToolTypeContext.Consumer>\n    </div>\n  );\n};\n\nexport default ToolPanel;\n","/Users/jinmingliu/work/ccc-react-paint/src/edit/index.tsx",[],"/Users/jinmingliu/work/ccc-react-paint/src/canvas/index.tsx",["332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348"],"/Users/jinmingliu/work/ccc-react-paint/src/right/index.tsx",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/tool/colorExtract.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/tool/pen.ts",["349","350","351"],"import { ColorType } from \"../toolType\";\nimport { hexToRgba, } from \"../colorChange\";\nimport Tool, { Point, getMousePos, setStraw, getTouchPos, hexToRgb,clacArea, updateImageData } from \"./tool\";\nimport { drawColorToPixel, isPointInPath } from \"./pixelUtil\";\n\nclass Pen extends Tool {\n  protected lineWidthBase = 1;\n  protected drawColorType = ColorType.MAIN;\n  protected eraser = \"\";\n  private mouseDown = false;\n  private saveImageData?: ImageData;\n  private previousPos: Point = {\n    x: 0,\n    y: 0\n  };\n  penColor: string ='' ;\n  private operateStart(pos: Point) {\n    if (!Tool.ctx) return;\n        setStraw(pos);\n  this.mouseDown = true;\n    const showColor = Tool.strawColor\n      ? Tool.strawColor\n      : this.drawColorType === ColorType.MAIN\n      ? Tool.mainColor\n        : Tool.subColor;\n    const testColor = hexToRgba(showColor)\n        this.previousPos = pos;\n    this.penColor = testColor\n    Tool.ctx.lineWidth = Tool.isPixel ? Tool.lineWidthFactor * this.lineWidthBase * Tool.OptPixel.size/2 : Tool.lineWidthFactor * this.lineWidthBase;\n    this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    Tool.ctx.strokeStyle = testColor;\n    Tool.ctx.lineJoin = \"round\";\n    Tool.ctx.lineCap = \"round\";\n    Tool.ctx.beginPath();\n    if (Tool.isPixel) { \n       drawColorToPixel(pos, pos, this.penColor);\n    }\n    }\n    \n  private operateMove(pos: Point) {\n    if (this.mouseDown) {\n      if (Tool.isPixel ) {\n        drawColorToPixel(this.previousPos, pos, this.penColor);\n        this.previousPos = pos;\n        return\n      } \n      Tool.ctx.moveTo(this.previousPos.x, this.previousPos.y);\n      const c = 0.5 * (this.previousPos.x + pos.x);\n      const d = 0.5 * (this.previousPos.y + pos.y);\n      Tool.ctx.quadraticCurveTo(c, d, pos.x, pos.y);\n      Tool.ctx.stroke();\n      this.previousPos = pos;\n    }\n  }\n  private operateEnd() {\n    if (this.mouseDown) {\n      Tool.ctx.closePath();\n      this.mouseDown = false;\n    //  let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    //    const showColor = Tool.strawColor\n    //   ? Tool.strawColor\n    //   : this.drawColorType === ColorType.MAIN\n    //   ? Tool.mainColor\n    //        : Tool.subColor;\n    //       const testColor = hexToRgba(showColor)\n    // const rgbaColor = parseColorString(testColor)\n    //   const colorRgb = hexToRgb(showColor);\n    //   if (colorRgb && this.saveImageData) {\n    //     imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, 0.5]);\n    //     Tool.ctx.putImageData(imageData, 0, 0);\n    //   }\n    }\n  }\n  \n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    if (clacArea(mousePos)) { \n    this.operateStart(mousePos);\n    }\n\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    event.preventDefault();\n    this.operateEnd();\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    this.operateMove(mousePos);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchPos);\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateMove(touchPos);\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this.operateEnd();\n  }\n}\n\nexport default Pen;\n","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/eraser.ts",["352"],"import { ColorType } from \"../toolType\";\nimport { drawColorToPixel, getPixelColorOnPixelBoxs, updatePixelBoxs } from \"./pixelUtil\";\nimport Tool, { Point, getMousePos, getPixelColorOnCanvas, getTouchPos, hexToRgb, updateImageData, clacArea } from \"./tool\";\nclass Eraser extends Tool {\n  protected lineWidthBase = 1;\n  private mouseDown = false;\n  private color = \"\";\n  private saveImageData?: ImageData;\n  private previousPos: Point = {\n    x: 0,\n    y: 0\n  };\n  public constructor(lineSize:number) {\n    super();\n    this.lineWidthBase = lineSize;\n    this.color = \"\";\n  }\n  private operateStart(pos: Point) {\n    if (!Tool.ctx) return;\n    this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n    this.mouseDown = true;\n    this.previousPos = pos;\n        Tool.ctx.lineWidth =Tool.isPixel ? this.lineWidthBase*Tool.OptPixel.size/2: this.lineWidthBase;\n\n    const newPos = {\n      x: pos.x -   Tool.ctx.lineWidth,\n      y:pos.y -   Tool.ctx.lineWidth\n    }\n\n    this.color = Tool.isPixel ? getPixelColorOnPixelBoxs(newPos) : getPixelColorOnCanvas(Tool.ctx, pos.x - 2, pos.y - 2);\n            console.log(this.color)\n\n    Tool.ctx.strokeStyle = this.color;\n    Tool.ctx.lineJoin = \"round\";\n    Tool.ctx.lineCap = \"round\";\n    Tool.ctx.beginPath();\n     if (Tool.isPixel) { \n       drawColorToPixel(pos, pos, this.color);\n    }\n  }\n  private operateMove(pos: Point) {\n    if (this.mouseDown) {\n      if (Tool.isPixel) { \n\t\t\t\tdrawColorToPixel(this.previousPos, pos, this.color);\n           this.previousPos = pos;\n           return\n         }\n      \n      Tool.ctx.moveTo(this.previousPos.x, this.previousPos.y);\n      const c = 0.5 * (this.previousPos.x + pos.x);\n      const d = 0.5 * (this.previousPos.y + pos.y);\n      Tool.ctx.quadraticCurveTo(c, d, pos.x, pos.y);\n      Tool.ctx.stroke();\n      this.previousPos = pos;\n    }\n  }\n  private operateEnd() {\n    if (this.mouseDown) {\n        Tool.ctx.closePath();\n        this.mouseDown = false;\n      if (!Tool.isPixel) { \n      let imageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n      const colorRgb = hexToRgb(this.color);\n      if (colorRgb && this.saveImageData) {\n        imageData = updateImageData(this.saveImageData, imageData, [colorRgb.r, colorRgb.g, colorRgb.b, colorRgb.a]);\n        Tool.ctx.putImageData(imageData, 0, 0);\n      }\n      }\n              updatePixelBoxs(Tool.ctx)\n\n     \n    }\n  }\n  public onMouseDown(event: MouseEvent): void {\n    event.preventDefault();\n\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n\n      if (clacArea(mousePos)) { \n    this.operateStart(mousePos);\n    }\n  }\n\n  public onMouseUp(event: MouseEvent): void {\n    event.preventDefault();\n    this.operateEnd();\n  }\n\n  public onMouseMove(event: MouseEvent): void {\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    this.operateMove(mousePos);\n  }\n\n  public onTouchStart(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateStart(touchPos);\n  }\n\n  public onTouchMove(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const touchPos = getTouchPos(event.target as HTMLCanvasElement, event);\n    this.operateMove(touchPos);\n  }\n\n  public onTouchEnd(event: TouchEvent): void {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this.operateEnd();\n  }\n}\n\nexport default Eraser;\n\n\n","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/colorFill.ts",["353","354"],"/Users/jinmingliu/work/ccc-react-paint/src/util/tool/Text.ts",["355","356","357","358","359","360"],"import { numberLiteralTypeAnnotation } from \"@babel/types\";\nimport { formatLongStrToArr } from \"./colorChange\";\nimport Tool, { Point, getMousePos, setStraw } from \"./tool\";\n\n// interface propsInput = {\n//             x?: number,\n//             y?: Number,\n//             maxWidth?:Number\n// }\n\nclass Text extends Tool {\n  private isMouseDown = false;\n  private _x: number;\n  private _y: number;\n  private textContent: string;\n  private textBox: any;\n  private fontStyle: any;\n  private canvas: any;\n  private canvasBox: any;\n  mousePos: Point;\n  width: number;\n  testList: any;\n  allCanvas: HTMLElement | null;\n  static currentDown: boolean;\n  static currentPos: { x: number; y: number; };\n  static currentCanvas: { x: number; y: number; };\n  static canvasList: Record<string, any> = {};\n  client: { x: any; y: any; } | undefined;\n  public constructor(fontType: any) {\n    super();\n    this._x = NaN;\n    this._y = NaN;\n    this.textBox = document.getElementById(\"textBox\");\n    this.canvasBox = document.getElementById(\"text-container\");\n    this.allCanvas  = document.getElementById(\"all-canvas\")\n    this.mousePos = {\n      x: 0,\n      y: 0\n    };\n    this.textContent = \"\";\n    this.fontStyle = {\n      fontSize: 72,\n      fontFamily: \"System Font\",\n      ...fontType\n    };\n    this.width = 10;\n    this.testList = {}\n    \n  }\n\n\n  private drawingText(x: number, y: number, arr: string[]) { \n    const textArea = document.createElement(\"textarea\")\n    this.allCanvas?.appendChild(textArea);\n  function mousemoveEv(e: MouseEvent) {\n       if (Text.currentDown) { \n         const clacx = e.clientX - Text.currentPos.x;\n          const clacy = e.clientY- Text.currentPos.y;\n         textArea.style.left =  Text.currentCanvas.x + clacx + 'px'\n         textArea.style.top =  Text.currentCanvas.y + clacy + 'px'\n       }\n     }\n    textArea.setAttribute(`style`,\n      `position:absolute;\n      left:${this._x}px;\n      background:#362F395E; \n      top: ${this._y}px;\n      cursor:pointer;\n      transform:scale(${Tool.currentScale});\n      transform-origin: left top;`);\n    \n    textArea.addEventListener(\"mousedown\", function (e) {\n      textArea.style.transform = `scale(${Tool.currentScale})`\n      Text.currentDown = true\n      Text.currentPos = {\n        x: e.clientX,\n        y:e.clientY,\n      }\n      Text.currentCanvas = {\n        x:Number(textArea.style.left.split('px')[0]),\n        y:Number(textArea.style.top.split('px')[0])\n      }\n    textArea.addEventListener(\"mousemove\", mousemoveEv);\n\n    });\n    textArea.addEventListener(\"mouseup\", function (e:MouseEvent) {\n      Text.currentDown = false\n      textArea.removeEventListener(\"mousemove\", mousemoveEv);\n     // canvas.style.background = 'transparent';\n      \n      Tool.textList = {\n        data: textArea,\n        textArea,\n        event:e,\n        pos: [Number(textArea.style.left.split('px')[0])+80, Number(textArea.style.top.split('px')[0])+80,]\n      }\n\n    });\n    this.calcCurrentElement(textArea)\n  }\n\n private calcCurrentElement =(ctx:HTMLElement)=> {\n if (this.fontStyle) { \n        const { fontSize, fontFamily, color, letterSpacing } = this.fontStyle;\n       ctx.setAttribute('font-size', fontSize)\n        ctx.setAttribute('font-family', fontSize)\n        ctx.setAttribute('color', color)\n        ctx.setAttribute('letterSpacing', letterSpacing)\n       }\n  }\n\n\n\n  private drawing(x: number, y: number,arr:string[]) {\n    const canvas = document.createElement(\"canvas\");\n    const { fontSize, fontFamily, color, lineHeight=24 ,letterSpacing } = this.fontStyle;\n    const showColor = Tool.strawColor || color\n    const canvasKey = `${new Date().getTime()}`;\n    canvas.width = Math.ceil(this.textBox.clientWidth); \n    canvas.height =Math.ceil(this.textBox.clientHeight);\n   // canvas.title = canvasKey\n    this.allCanvas?.appendChild(canvas);\n\n //\n    \n    function mousemoveEv(e: MouseEvent) {\n       if (Text.currentDown) { \n         const clacx = e.clientX - Text.currentPos.x;\n          const clacy = e.clientY- Text.currentPos.y;\n         canvas.style.left =  Text.currentCanvas.x + clacx + 'px'\n         canvas.style.top =  Text.currentCanvas.y + clacy + 'px'\n       }\n     }\n    canvas.setAttribute(`style`,\n      `position:absolute;left:${this._x}px;top:${this._y}px;cursor:pointer;transform:scale(${Tool.currentScale});transform-origin: left top;`);\n   \n    canvas.addEventListener(\"mousedown\", function (e) {\n      canvas.style.transform = `scale(${Tool.currentScale})`\n      canvas.style.background = '#362F395E';\n      Text.currentDown = true\n      Text.currentPos = {\n        x: e.clientX,\n        y:e.clientY,\n      }\n      Text.currentCanvas = {\n        x:Number(canvas.style.left.split('px')[0]),\n        y:Number(canvas.style.top.split('px')[0])\n      }\n    canvas.addEventListener(\"mousemove\", mousemoveEv);\n\n    });\n    canvas.addEventListener(\"mouseup\", function (e:MouseEvent) {\n      Text.currentDown = false\n      canvas.removeEventListener(\"mousemove\", mousemoveEv);\n      canvas.style.background = 'transparent';\n      Tool.textList[canvasKey] = {\n        data: canvas.toDataURL(),\n        canvas,\n        event:e,\n        pos: [Number(canvas.style.left.split('px')[0])+80, Number(canvas.style.top.split('px')[0])+80,]\n      }\n\n    });\n    \n    const context = canvas.getContext('2d');\n    if (!context) {\n      return;\n    } else {\n      // 设置画笔的颜色和大小\n      context.fillStyle = \"#000\"; // 填充颜色为红色\n      context.lineWidth = 5; // 指定描边线的宽度\n      context.font = \"72px System Font\";\n      if (context && this.fontStyle) {\n        context.fillStyle = showColor || \"#000\";\n        context.font = `${fontSize}px ${fontFamily}`;\n        if (context.canvas && letterSpacing) {\n          context.canvas.style.letterSpacing = letterSpacing;\n        }\n      }\n      let showArr: string[] = [];\n      let showWidth = 0;\n      arr.forEach(va => { \n        const textWidth = Number(context.measureText(va).width);\n        if (textWidth > canvas.width) {\n          showWidth= canvas.width\n          const showNum = Math.floor((canvas.width - 14) / Math.ceil(textWidth / va.length));\n          const newArr = formatLongStrToArr(va,showNum)\n          showArr.push(...newArr)\n        } else { \n          showWidth =Math.max(textWidth,showWidth);\n          showArr.push(va)\n        }\n      })\n      const showHeight = canvas.height + (showArr.length - 1) * lineHeight\n      context.canvas.style.height = showHeight+'px';\n      //context.canvas.height = Math.ceil(showHeight);\n      const height = Math.floor(canvas.height / showArr.length)    \n      //canvas.height = canvas.height + (showArr.length - 1) * lineHeight\n      if (showArr.length > 0) {\n        showArr.forEach((va, i) => {\n          context.fillText(va, 7, height/2 +fontSize/4 + height*i );\n        })\n        \n        Tool.textList[canvasKey] = {\n          data: canvas.toDataURL(), canvas,\n          pos: [this._x + 80, this._y +80]\n        }\n        this.textBox.setAttribute(\"style\", `z-index:-1;display:none`);\n        this.canvasBox.setAttribute(\"style\", `z-index:-2`);\n        this.textBox.value = \"\";\n\n      }\n    }\n  }\n\n  private startText() {\n    this.textContent = this.textBox.value;\n    this.isMouseDown = false;\n    if (this.textContent) {\n      const arr = this.textBox.value.split(/[(\\r\\n)\\r\\n]+/);\n      this.drawing(this.mousePos.x, this.mousePos.y, arr);\n      //this.drawingText(this.mousePos.x, this.mousePos.y, arr)\n    } else { \n       this.textBox.setAttribute(\"style\", `z-index:-1;display:none`);\n        this.canvasBox.setAttribute(\"style\", `z-index:-2`);\n        this.textBox.value = \"\";\n    }\n   \n  }\n\n\n  private drawLastText() { \n    Object.keys(Tool.textList).forEach((va) => {\n      const { data, pos } = Tool.textList[va];\n      const img = new Image();\n              img.crossOrigin = \"anonymous\";\n              img.src = data;\n              img.onload = function () {\n                /*1.在canvas 中绘制图像*/\n                const { x, y } = getMousePos(\n                  Tool.ctx.canvas,\n                  undefined,\n                  undefined,\n                  {\n                    x: pos[0],\n                    y: pos[1],\n                  }\n                );\n                Tool.ctx.drawImage(img, x, y);\n              };\n              document\n                .getElementById(\"all-canvas\")\n                ?.removeChild(Tool.textList[va].canvas);\n   });\n    Tool.textList = {}\n  }\n\n  public onKeyDown(event: any): void {\n        //  event.preventDefault();\n    if (event.keyCode == 8) {\n      //delete \n      Object.keys(Tool.textList).forEach(va => { \n              document\n                .getElementById(\"all-canvas\")\n                ?.removeChild(Tool.textList[va].canvas);\n      })\n      Tool.textList = {}\n\n    }\n  }\n\n  public onMouseDown(event: any): void {\n    // 鼠标按下位置保存\n    event.preventDefault();\n    const mousePos = getMousePos(Tool.ctx.canvas, event);\n    if (Tool.strawFlag) { \n        setStraw(mousePos)\n      return\n    }\n    if (this.isMouseDown) {\n      this.startText();\n\n    } else if (!this.isMouseDown) {\n       this.drawLastText()\n      this.mousePos = mousePos;\n        this._x = event.clientX - 80; // event.offsetX; // 鼠标按下时保存当前位置，为起始位置\n        this._y = event.clientY - 80; //event.offsetY;\n        //  新建文本\n      this.client = {\n        x: event.clientX,\n        y: event.clientY\n      }\n      this.isMouseDown = true;\n      this.textBox.innerText = \"\";\n      let textStyleStr =  `display:block;\n        position:absolute;\n        z-index:6;\n        width:auto;\n        left:${this._x}px;\n        top:${this._y}px;\n        `\n      const { fontSize, fontFamily, color,lineHeight=24, letterSpacing } = this.fontStyle;\n      const showColor = Tool.strawColor ||color\n       if (this.fontStyle) { \n      textStyleStr = `${textStyleStr}; font-size:${fontSize}px;font-family:${fontFamily};color:${showColor};letterSpacing:${letterSpacing};`;\n       }\n      const width = this.canvasBox.clientWidth - this._x;\n      //const height = this.canvasBox.clientHeight - this._y\n      textStyleStr = `${textStyleStr} max-width:${width}px;`\n      if (fontSize /2 < 260) { \n        textStyleStr = `${textStyleStr} width:${260}px;`\n      }\n      this.width = width\n      this.canvasBox.setAttribute(\"style\", `z-index:5;display:block,pointer-events:auto`);\n      this.textBox.setAttribute(\"style\",textStyleStr);\n    }\n  }\n}\n\nexport default Text;\n","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/shape.ts",["361","362","363"],"import {ShapeToolType} from \"../toolType\";\nimport { drawColorToPixel, updatePixelBoxs } from \"./pixelUtil\";\nimport Tool, {Point, getMousePos, getTouchPos,setStraw, hexToRgb,clacArea, updateImageData} from \"./tool\";\n\n/**\n * 根据形状类型，获取要绘制的形状的顶点(圆形，返回圆心)\n * @param type shape type\n * @param sx x coord of start\n * @param sy y coord of start\n * @param ex x coord of end\n * @param ey y coord of end\n */\nconst getVertexs = (type: ShapeToolType, sx: number, sy: number, ex: number, ey: number): Point[] => {\n    const points: Point[] = [];\n    const mx = 0.5 * (sx + ex), my = 0.5 * (sy + ey);\n\n    switch (type) {\n        case ShapeToolType.LINE:\n            points.push({x: sx, y: sy});\n            points.push({x: ex, y: ey});\n            break;\n        case ShapeToolType.RECT:\n            points.push({x: sx, y: sy});\n            points.push({x: ex, y: sy});\n            points.push({x: ex, y: ey});\n            points.push({x: sx, y: ey});\n            break;\n        case ShapeToolType.CIRCLE:\n            points.push({x: 0.5 * (sx + ex), y: 0.5 * (sy + ey)});\n            break;\n        case ShapeToolType.RHOMBUS:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.TRIANGLE:\n            points.push({x: mx, y: sy});\n            points.push({x: sx, y: ey});\n            points.push({x: ex, y: ey});\n            break;\n        case ShapeToolType.PENTAGON:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: 0.5 * (mx + ex), y: ey});\n            points.push({x: 0.5 * (mx + sx), y: ey});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.SEXANGLE:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: 0.5 * (sy + my)});\n            points.push({x: ex, y: 0.5 * (ey + my)});\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: 0.5 * (ey + my)});\n            points.push({x: sx, y: 0.5 * (sy + my)});\n            break;\n        case ShapeToolType.ARROW_TOP:\n            points.push({x: mx, y: sy});\n            points.push({x: ex, y: my});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: my});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: ey});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: ey});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: my});\n            points.push({x: sx, y: my});\n            break;\n        case ShapeToolType.ARROW_RIGHT:\n            points.push({x: ex, y: my});\n            points.push({x: mx, y: ey});\n            points.push({x: mx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: sx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: sx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: sy});\n            break;\n        case ShapeToolType.ARROW_DOWN:\n            points.push({x: mx, y: ey});\n            points.push({x: sx, y: my});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: my});\n            points.push({x: sx + 1 / 3 * (ex - sx), y: sy});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: sy});\n            points.push({x: ex - 1 / 3 * (ex - sx), y: my});\n            points.push({x: ex, y: my});\n            break;\n        case ShapeToolType.ARROW_LEFT:\n            points.push({x: sx, y: my});\n            points.push({x: mx, y: sy});\n            points.push({x: mx, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: ex, y: sy + 1 / 3 * (ey - sy)});\n            points.push({x: ex, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: ey - 1 / 3 * (ey - sy)});\n            points.push({x: mx, y: ey});\n            break;\n        case ShapeToolType.FOUR_STAR:\n            const offsetX = 0.125 * (ex - sx), offsetY = 0.125 * (ey - sy);\n            points.push({x: mx, y: sy});\n            points.push({x: mx + offsetX, y: my - offsetY});\n            points.push({x: ex, y: my});\n            points.push({x: mx + offsetX, y: my + offsetY});\n            points.push({x: mx, y: ey});\n            points.push({x: mx - offsetX, y: my + offsetY});\n            points.push({x: sx, y: my});\n            points.push({x: mx - offsetX, y: my - offsetY});\n            break;\n        default:\n            break;\n    }\n    return points;\n};\n\nclass Shape extends Tool {\n    private type: ShapeToolType;\n    private saveImageData?: ImageData;\n    private isMouseDown = false;\n    private mouseDownPos = {x: 0, y: 0};\n    private lineWidthBase = 1;\n    public isDashed = false;\n    private dashLineStyle = [10, 10];\n    static shapeWidth: any = 1;\n    public constructor(type: ShapeToolType, dashed = false) {\n        super();\n        this.type = type;\n        this.isDashed = dashed;\n    }\n\n    public setType(type: ShapeToolType) {\n        this.type = type;\n    }\n\n    private operateStart(pos: { x: number; y: number }) {\n        setStraw(pos)\n        const lineWidth = Shape.shapeWidth || 1;\n        this.saveImageData = Tool.ctx.getImageData(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n        this.isMouseDown = true;\n        this.mouseDownPos = pos;\n        Tool.ctx.strokeStyle = Tool.mainColor;\n        Tool.ctx.lineWidth = Tool.isPixel?lineWidth*Tool.OptPixel.size:lineWidth;//5// Tool.lineWidthFactor * this.lineWidthBase;\n        Tool.ctx.fillStyle = Tool.subColor;\n        if (this.isDashed) {\n            Tool.ctx.setLineDash(this.dashLineStyle);\n        }\n\n    }\n\n    private operateMove(pos: { x: number; y: number }) {\n        const ctx = Tool.ctx;\n        if (this.isMouseDown && this.saveImageData) {\n            ctx.clearRect(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n            ctx.putImageData(this.saveImageData, 0, 0);\n            const vertexs: Point[] = getVertexs(this.type, this.mouseDownPos.x, this.mouseDownPos.y, pos.x, pos.y);\n            if (this.type === ShapeToolType.CIRCLE) {\n                ctx.beginPath();\n                ctx.ellipse(vertexs[0].x, vertexs[0].y, Math.abs(0.5 * (pos.x - this.mouseDownPos.x)), Math.abs(0.5 * (pos.y - this.mouseDownPos.y)), 0, 0, Math.PI * 2);\n                ctx.stroke();\n            } else {\n                ctx.beginPath();\n                 ctx.moveTo(vertexs[0].x, vertexs[0].y);\n                for (let i = 1; i < vertexs.length; i++) {\n                    ctx.lineTo(vertexs[i].x, vertexs[i].y);\n                }\n                ctx.closePath();\n                ctx.stroke();\n            }\n                         if (Tool.isPixel) { \n         updatePixelBoxs(Tool.ctx);\n        }\n      \n        }\n    }\n    \n    private operateEnd() {\n        Tool.ctx.setLineDash([]);\n        if (Tool.isPixel) { \n         updatePixelBoxs(Tool.ctx);\n        }\n        this.isMouseDown = false;\n        this.saveImageData = undefined;\n    }\n\n    public onMouseDown(event: MouseEvent): void {\n        event.preventDefault();\n        const mousePos = getMousePos(Tool.ctx.canvas, event);\n          if (clacArea(mousePos)) { \n            this.operateStart(mousePos);\n          }\n    }\n\n    public onMouseMove(event: MouseEvent): void {\n        event.preventDefault();\n        const mousePos = getMousePos(Tool.ctx.canvas, event);\n        this.operateMove(mousePos);\n    }\n\n    public onMouseUp(event: MouseEvent): void {\n        event.preventDefault();\n        this.operateEnd();\n    }\n\n    public onTouchStart(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        const canvas = event.target as HTMLCanvasElement;\n        const touchPos = getTouchPos(canvas, event);\n\n        this.operateStart(touchPos);\n    }\n\n    public onTouchMove(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        const canvas = event.target as HTMLCanvasElement;\n        const touchPos = getTouchPos(canvas, event);\n\n        this.operateMove(touchPos);\n    }\n\n    public onTouchEnd(event: TouchEvent): void {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        this.operateEnd();\n    }\n}\n\nexport default Shape;\n","/Users/jinmingliu/work/ccc-react-paint/src/util/dispatcher/event.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/ToolTypeIcon.tsx",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/colorChange.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/tool/colorChange.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/util/snapshot/index.ts",[],"/Users/jinmingliu/work/ccc-react-paint/src/right/pen/index.tsx",["364","365"],"/Users/jinmingliu/work/ccc-react-paint/src/right/showShape/index.tsx",["366","367"],"/Users/jinmingliu/work/ccc-react-paint/src/right/earser/index.tsx",["368"],"/Users/jinmingliu/work/ccc-react-paint/src/right/text/index.tsx",["369"],"import React, { useEffect } from \"react\";\nimport { useContext } from \"react\";\nimport { TextContext } from \"@/context\";\nimport \"./index.less\";\nimport { Select } from \"antd\";\nimport IntegerStep from \"../components/slider\";\nimport ColorPanel from \"../components/colorPanel\";\nimport { useMemo } from \"react\";\nimport { DownOutlined } from \"@ant-design/icons\";\nimport arrow from \"@/assets/icon/arrow.svg\";\n\nconst { Option } = Select;\n\ninterface FormatColor {\n  className?: string;\n  maxSize?: number;\n}\n\nconst textFamily = [\n  \"Barlow-ExtraBold\",\n  \"DIN-AlternateBold\",\n  \"Trebuchet-MSBold\",\n  \"Trebuchet-MS\",\n  \"Poppins-Bold\",\n  \"Poppins-Light\",\n  \"Poppins-Medium\",\n  \"Poppins-Regular\",\n  \"Poppins-SemiBold\",\n  \"System Font\",\n];\n\nconst FormatColor: React.FC<FormatColor> = (props) => {\n  const { className, maxSize = 100 } = props;\n  const TextToolContext = useContext(TextContext);\n  const fontStyle = useMemo(() => {\n    return TextToolContext.fontStyle;\n  }, [TextToolContext.fontStyle]);\n\n  useEffect(() => {\n    TextToolContext.setFont({\n      ...fontStyle,\n      fontSize: maxSize / 2,\n    });\n    // TextToolContext.fontStyle.fontSize = maxSize / 2;\n  }, [maxSize]);\n\n  const handleChange = (type: string, value: string | number) => {\n    const textBox = document.getElementById(\"textBox\");\n    if (textBox && textBox.style.display !== \"none\") {\n      textBox.setAttribute(\"style\", `z-index:-1;display:none`);\n    }\n    TextToolContext.setFont({\n      ...fontStyle,\n      [type]: value,\n    });\n  };\n\n  return (\n    <div\n      className={\n        className ? `ccc-text formatColor ${className}` : \"ccc-text colorpanel\"\n      }\n    >\n      <div className=\"ccc-text-box\">\n        <div>\n          <h3>Font</h3>\n          <Select\n            defaultValue=\"System Font\"\n            className=\"ccc-text-family paint-select\"\n            dropdownClassName=\"paint-select-dropCard\"\n            //  open={true}\n            onChange={(value: string) => {\n              handleChange(\"fontFamily\", value);\n            }}\n            suffixIcon={\n              <img style={{ width: \"15px\", marginRight: \"10px\" }} src={arrow} />\n            }\n          >\n            {textFamily.map((va) => {\n              return (\n                <Option key={va} value={va}>\n                  {va}\n                </Option>\n              );\n            })}\n          </Select>\n        </div>\n        <div className=\"font\">\n          <h3>Letter Spacing</h3>\n          <IntegerStep\n            min={1}\n            max={8}\n            onPropsChange={(value) => {\n              handleChange(\"letterSpacing\", value + \"px\");\n\n              // TextToolContext.setFont({\n              //   ...fontStyle,\n              //   letterSpacing: value + \"px\",\n              // });\n            }}\n          />\n        </div>\n        <div className=\"font\">\n          <h3>Font Size</h3>\n          <IntegerStep\n            min={12}\n            max={maxSize * 2}\n            value={Math.ceil(maxSize / 2)}\n            onPropsChange={(value) => {\n              handleChange(\"fontSize\", value);\n              // TextToolContext.setFont({\n              //   ...fontStyle,\n              //   fontSize: value,\n              // });\n            }}\n          />\n        </div>\n        {/* <div className=\"font\">\n          <h3>Line Height</h3>\n          <IntegerStep\n            min={24}\n            max={maxSize}\n            onPropsChange={(value) => {\n              TextToolContext.setFont({\n                ...fontStyle,\n                lineHeight: value,\n              });\n            }}\n          /> \n        </div> */}\n        <div className=\"material-color-box\">\n          <ColorPanel\n            type=\"text\"\n            className=\"toolbar-item\"\n            onChange={(color: string) => {\n              TextToolContext.setFont({\n                ...fontStyle,\n                color: color,\n              });\n            }}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default FormatColor;\n","/Users/jinmingliu/work/ccc-react-paint/src/right/formatColor/index.tsx",[],"/Users/jinmingliu/work/ccc-react-paint/src/right/components/colorPanel/index.tsx",["370"],"/Users/jinmingliu/work/ccc-react-paint/src/right/components/slider/index.tsx",[],"/Users/jinmingliu/work/ccc-react-paint/src/right/components/shape/index.tsx",[],"/Users/jinmingliu/work/ccc-react-paint/src/piexCanvas/index.tsx",["371","372","373","374","375","376","377","378","379","380","381","382","383","384","385"],"/Users/jinmingliu/work/ccc-react-paint/src/piexCanvas/Pixel.tsx",["386"],"export interface Point {\n  x: number;\n  y: number;\n}\n\nclass Pixel {\n  lineWidth: number;\n  strokeStyle: string | CanvasGradient | CanvasPattern;\n  fillStyle: string | CanvasGradient | CanvasPattern;\n  isFill: any;\n  size: number;\n  x: number;\n  y: number;\n  shape: string;\n  filled: boolean | undefined;\n  constructor(option: {\n    x: number;\n    y: number;\n    shape: string;\n    size?: number;\n    fillStyle: string | CanvasGradient | CanvasPattern;\n    isFill: any;\n    strokeStyle: string | CanvasGradient | CanvasPattern;\n  }) {\n    this.lineWidth = 0;\n    this.x = option.x;\n    this.y = option.y;\n    this.shape = option.shape;\n    this.size = option.size || 16;\n    this.fillStyle = option.fillStyle;\n    this.isFill = option.isFill;\n    this.strokeStyle = \"transparent\";\n  }\n\n  setColor(color: string) {\n    this.fillStyle = color;\n    this.filled = true;\n  }\n\n  getColor() {\n    return this.fillStyle;\n  }\n\n  createPath(ctx: CanvasRenderingContext2D) {\n    if (this.shape === \"rect\") {\n      this.createRect(ctx);\n    } else {\n      this.createCircle(ctx);\n    }\n  }\n\n  getPoints() {\n    let p1 = { x: this.x - this.size / 2, y: this.y - this.size / 2 };\n    let p2 = { x: this.x + this.size / 2, y: this.y - this.size / 2 };\n    let p3 = { x: this.x + this.size / 2, y: this.y + this.size / 2 };\n    let p4 = { x: this.x - this.size / 2, y: this.y + this.size / 2 };\n    return [p1, p2, p3, p4];\n  }\n\n  createCircle(ctx: CanvasRenderingContext2D) {\n    let radius = this.size / 2;\n    ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);\n  }\n\n  createRect(ctx: CanvasRenderingContext2D) {\n    let points = this.getPoints();\n    ctx.fillRect(this.x, this.y, this.size, this.size);\n    // points.forEach(function (point, i) {\n    //   ctx[i == 0 ? \"moveTo\" : \"lineTo\"](point.x, point.y);\n    // });\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.save();\n    ctx.lineWidth = this.lineWidth;\n    ctx.strokeStyle = this.strokeStyle;\n    ctx.fillStyle = this.fillStyle;\n    ctx.beginPath();\n    this.createPath(ctx);\n    if (this.isFill) {\n      ctx.fill();\n    } else {\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  /**\n   * @param  {Object} p {x: num, y: num}\n   * @description 判断点是否在这个路径上, 构造路径利用isPointInPath判断点是否在此路径上不用绘制到canvas上\n   */\n  isPointInPath(ctx: CanvasRenderingContext2D, p: Point): boolean {\n    let isIn = false;\n    ctx.save();\n    ctx.beginPath();\n    this.createPath(ctx);\n    if (ctx.isPointInPath(p.x, p.y)) {\n      isIn = true;\n    }\n    ctx.closePath();\n    ctx.restore();\n    return isIn;\n  }\n}\nexport default Pixel;\n","/Users/jinmingliu/work/ccc-react-paint/src/util/tool/pixelUtil.tsx",["387","388"],"import Tool, { Point } from \"./tool\";\n\nconst sqr = (x: number) => {\n  return x * x;\n};\n\nconst dist2 = (p1: Point, p2: Point) => {\n  return sqr(p1.x - p2.x) + sqr(p1.y - p2.y);\n};\n\nexport const getPixelColorOnPixelBoxs = (pos: Point): string => {\n  for (let i = 0; i < Tool.PixelBoxs.length; i++) {\n    const pixel = Tool.PixelBoxs[i];\n    if (\n      pixel.x - Tool.OptPixel.size / 2 <= pos.x &&\n      pos.x <= pixel.x + Tool.OptPixel.size / 2 &&\n      pixel.y - Tool.OptPixel.size / 2 <= pos.y &&\n      pos.y <= pixel.y + Tool.OptPixel.size / 2\n    ) {\n      return pixel.getColor();\n    }\n  }\n  return \"\";\n};\n\nexport const updatePixelBoxs = (\n  ctx: CanvasRenderingContext2D,\n  imageData?: any\n) => {\n  const ctxWidth = ctx.canvas.width;\n  const ctxHeight = ctx.canvas.height;\n  const imgData = imageData || ctx.getImageData(0, 0, ctxWidth, ctxHeight).data;\n  let array = [];\n  for (let x = 0; x < ctxWidth; x += Tool.OptPixel.size) {\n    for (let y = 0; y < ctxHeight; y += Tool.OptPixel.size) {\n      let index = y * ctxWidth + x;\n      let i = index * 4;\n      let rgb = `rgba(${imgData[i]},${imgData[i + 1]},${imgData[i + 2]})`;\n      array.push(rgb);\n    }\n  }\n  if (Tool.PixelBoxs.length > 0) {\n    for (let index = 0; index < array.length; index++) {\n      Tool.PixelBoxs[index].setColor(array[index]);\n    }\n    refresh();\n  }\n};\n\n//像素风改色功能\nexport const drawColorToPixel = (p1: Point, p2: Point, color: string) => {\n  let mainPixel: any;\n  const size: number = Tool.ctx.lineWidth / (Tool.OptPixel.size / 2);\n  Tool.PixelBoxs.forEach((pixel, index) => {\n    const p = {\n      x: pixel.x,\n      y: pixel.y,\n    };\n    const distance = distToSegment(p, p1, p2, Tool.ctx.lineWidth);\n    // if (distance <= Tool.ctx.lineWidth && !mainPixel) {\n    //   const pixel = Tool.PixelBoxs[index];\n    //   pixel.setColor(color);\n    //   mainPixel = pixel;\n    // } else if (mainPixel && size > 1) {\n    //   if (\n    //     pixel.x - mainPixel.x <= Tool.OptPixel.size * size &&\n    //     pixel.y - mainPixel.y <= Tool.OptPixel.size * size &&\n    //     pixel.y >= mainPixel.y\n    //   ) {\n    //     pixel.setColor(color);\n    //   }\n    // }\n\n    if (distance <= Tool.ctx.lineWidth) {\n      const pixel = Tool.PixelBoxs[index];\n      pixel.setColor(color);\n    }\n  });\n  refresh();\n};\n\n//刷新\nexport const refresh = () => {\n  Tool.ctx.clearRect(0, 0, Tool.ctx.canvas.width, Tool.ctx.canvas.height);\n  for (let i = 0; i < Tool.PixelBoxs.length; i++) {\n    const pixel = Tool.PixelBoxs[i];\n    pixel.draw(Tool.ctx);\n  }\n};\n\n/**\n * @description 计算线段与圆是否相交\n * @param {x: num, y: num} p 圆心点\n * @param {x: num, y: num} v 线段起始点\n * @param {x: num, y: num} w 线段终点\n */\nexport const distToSegmentSquared = (p: Point, v: Point, w: Point) => {\n  const l2 = dist2(v, w);\n  if (l2 == 0) return dist2(p, v);\n  const t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n  if (t < 0) return dist2(p, v);\n  if (t > 1) return dist2(p, w);\n  return dist2(p, {\n    x: v.x + t * (w.x - v.x),\n    y: v.y + t * (w.y - v.y),\n  });\n};\n\nconst distToSegment = (p: Point, v: Point, w: Point, offset: number) => {\n  const minX = Math.min(v.x, w.x) - offset;\n  const maxX = Math.max(v.x, w.x) + offset;\n  const minY = Math.min(v.y, w.y) - offset;\n  const maxY = Math.max(v.y, w.y) + offset;\n\n  if ((p.x < minX || p.x > maxX) && (p.y < minY || p.y > maxY)) {\n    return Number.MAX_VALUE;\n  }\n  return Math.sqrt(distToSegmentSquared(p, v, w));\n};\n\nexport const isPointInPath = (\n  ctx: CanvasRenderingContext2D,\n  p: Point\n): boolean => {\n  let isIn = false;\n  ctx.save();\n  ctx.beginPath();\n  if (ctx.isPointInPath(p.x, p.y)) {\n    isIn = true;\n  }\n  ctx.closePath();\n  ctx.restore();\n  return isIn;\n};\n",{"ruleId":"389","severity":1,"message":"390","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":20},{"ruleId":"389","severity":1,"message":"393","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":24},{"ruleId":"389","severity":1,"message":"394","line":65,"column":5,"nodeType":"391","messageId":"392","endLine":65,"endColumn":13},{"ruleId":"395","severity":1,"message":"396","line":250,"column":9,"nodeType":"397","messageId":"398","endLine":250,"endColumn":18,"suggestions":"399"},{"ruleId":"395","severity":1,"message":"396","line":257,"column":23,"nodeType":"397","messageId":"398","endLine":257,"endColumn":36,"suggestions":"400"},{"ruleId":"395","severity":1,"message":"396","line":288,"column":23,"nodeType":"397","messageId":"398","endLine":288,"endColumn":36,"suggestions":"401"},{"ruleId":"395","severity":1,"message":"396","line":296,"column":22,"nodeType":"397","messageId":"398","endLine":296,"endColumn":32,"suggestions":"402"},{"ruleId":"395","severity":1,"message":"396","line":297,"column":21,"nodeType":"397","messageId":"398","endLine":297,"endColumn":31,"suggestions":"403"},{"ruleId":"395","severity":1,"message":"396","line":397,"column":23,"nodeType":"397","messageId":"398","endLine":397,"endColumn":36,"suggestions":"404"},{"ruleId":"389","severity":1,"message":"405","line":398,"column":31,"nodeType":"391","messageId":"392","endLine":398,"endColumn":37},{"ruleId":"395","severity":1,"message":"396","line":399,"column":37,"nodeType":"397","messageId":"398","endLine":399,"endColumn":47,"suggestions":"406"},{"ruleId":"389","severity":1,"message":"407","line":400,"column":20,"nodeType":"391","messageId":"392","endLine":400,"endColumn":31},{"ruleId":"389","severity":1,"message":"408","line":400,"column":41,"nodeType":"391","messageId":"392","endLine":400,"endColumn":53},{"ruleId":"395","severity":1,"message":"396","line":401,"column":7,"nodeType":"397","messageId":"398","endLine":401,"endColumn":17,"suggestions":"409"},{"ruleId":"395","severity":1,"message":"396","line":446,"column":7,"nodeType":"397","messageId":"398","endLine":446,"endColumn":14,"suggestions":"410"},{"ruleId":"389","severity":1,"message":"411","line":464,"column":13,"nodeType":"391","messageId":"392","endLine":464,"endColumn":20},{"ruleId":"389","severity":1,"message":"412","line":464,"column":22,"nodeType":"391","messageId":"392","endLine":464,"endColumn":29},{"ruleId":"395","severity":1,"message":"396","line":486,"column":7,"nodeType":"397","messageId":"398","endLine":486,"endColumn":14,"suggestions":"413"},{"ruleId":"395","severity":1,"message":"396","line":12,"column":58,"nodeType":"397","messageId":"398","endLine":12,"endColumn":62,"suggestions":"414"},{"ruleId":"389","severity":1,"message":"415","line":1,"column":10,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"416","line":2,"column":8,"nodeType":"391","messageId":"392","endLine":2,"endColumn":13},{"ruleId":"389","severity":1,"message":"417","line":3,"column":59,"nodeType":"391","messageId":"392","endLine":3,"endColumn":67},{"ruleId":"389","severity":1,"message":"418","line":3,"column":78,"nodeType":"391","messageId":"392","endLine":3,"endColumn":93},{"ruleId":"389","severity":1,"message":"417","line":2,"column":57,"nodeType":"391","messageId":"392","endLine":2,"endColumn":65},{"ruleId":"389","severity":1,"message":"418","line":2,"column":76,"nodeType":"391","messageId":"392","endLine":2,"endColumn":91},{"ruleId":"389","severity":1,"message":"419","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"420","line":7,"column":10,"nodeType":"391","messageId":"392","endLine":7,"endColumn":14},{"ruleId":"389","severity":1,"message":"419","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"421","line":4,"column":10,"nodeType":"391","messageId":"392","endLine":4,"endColumn":22},{"ruleId":"389","severity":1,"message":"421","line":9,"column":10,"nodeType":"391","messageId":"392","endLine":9,"endColumn":22},{"ruleId":"389","severity":1,"message":"419","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"422","line":21,"column":7,"nodeType":"391","messageId":"392","endLine":21,"endColumn":25},{"ruleId":"389","severity":1,"message":"423","line":1,"column":10,"nodeType":"391","messageId":"392","endLine":1,"endColumn":37},{"ruleId":"389","severity":1,"message":"424","line":52,"column":23,"nodeType":"391","messageId":"392","endLine":52,"endColumn":32},{"ruleId":"389","severity":1,"message":"425","line":52,"column":34,"nodeType":"391","messageId":"392","endLine":52,"endColumn":43},{"ruleId":"389","severity":1,"message":"426","line":52,"column":45,"nodeType":"391","messageId":"392","endLine":52,"endColumn":58},{"ruleId":"389","severity":1,"message":"427","line":104,"column":27,"nodeType":"391","messageId":"392","endLine":104,"endColumn":37},{"ruleId":"389","severity":1,"message":"428","line":302,"column":43,"nodeType":"391","messageId":"392","endLine":302,"endColumn":53},{"ruleId":"389","severity":1,"message":"390","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":20},{"ruleId":"389","severity":1,"message":"429","line":31,"column":10,"nodeType":"391","messageId":"392","endLine":31,"endColumn":16},{"ruleId":"389","severity":1,"message":"430","line":32,"column":8,"nodeType":"391","messageId":"392","endLine":32,"endColumn":14},{"ruleId":"389","severity":1,"message":"431","line":69,"column":10,"nodeType":"391","messageId":"392","endLine":69,"endColumn":19},{"ruleId":"389","severity":1,"message":"432","line":1,"column":10,"nodeType":"391","messageId":"392","endLine":1,"endColumn":34},{"ruleId":"395","severity":1,"message":"396","line":17,"column":59,"nodeType":"397","messageId":"398","endLine":17,"endColumn":63,"suggestions":"433"},{"ruleId":"389","severity":1,"message":"434","line":7,"column":3,"nodeType":"391","messageId":"392","endLine":7,"endColumn":12},{"ruleId":"389","severity":1,"message":"393","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":24},{"ruleId":"389","severity":1,"message":"394","line":65,"column":5,"nodeType":"391","messageId":"392","endLine":65,"endColumn":13},{"ruleId":"395","severity":1,"message":"396","line":250,"column":9,"nodeType":"397","messageId":"398","endLine":250,"endColumn":18,"suggestions":"435"},{"ruleId":"395","severity":1,"message":"396","line":257,"column":23,"nodeType":"397","messageId":"398","endLine":257,"endColumn":36,"suggestions":"436"},{"ruleId":"395","severity":1,"message":"396","line":288,"column":23,"nodeType":"397","messageId":"398","endLine":288,"endColumn":36,"suggestions":"437"},{"ruleId":"395","severity":1,"message":"396","line":296,"column":22,"nodeType":"397","messageId":"398","endLine":296,"endColumn":32,"suggestions":"438"},{"ruleId":"395","severity":1,"message":"396","line":297,"column":21,"nodeType":"397","messageId":"398","endLine":297,"endColumn":31,"suggestions":"439"},{"ruleId":"395","severity":1,"message":"396","line":397,"column":23,"nodeType":"397","messageId":"398","endLine":397,"endColumn":36,"suggestions":"440"},{"ruleId":"389","severity":1,"message":"405","line":398,"column":31,"nodeType":"391","messageId":"392","endLine":398,"endColumn":37},{"ruleId":"395","severity":1,"message":"396","line":399,"column":37,"nodeType":"397","messageId":"398","endLine":399,"endColumn":47,"suggestions":"441"},{"ruleId":"389","severity":1,"message":"407","line":400,"column":20,"nodeType":"391","messageId":"392","endLine":400,"endColumn":31},{"ruleId":"389","severity":1,"message":"408","line":400,"column":41,"nodeType":"391","messageId":"392","endLine":400,"endColumn":53},{"ruleId":"395","severity":1,"message":"396","line":401,"column":7,"nodeType":"397","messageId":"398","endLine":401,"endColumn":17,"suggestions":"442"},{"ruleId":"395","severity":1,"message":"396","line":446,"column":7,"nodeType":"397","messageId":"398","endLine":446,"endColumn":14,"suggestions":"443"},{"ruleId":"389","severity":1,"message":"411","line":464,"column":13,"nodeType":"391","messageId":"392","endLine":464,"endColumn":20},{"ruleId":"389","severity":1,"message":"412","line":464,"column":22,"nodeType":"391","messageId":"392","endLine":464,"endColumn":29},{"ruleId":"395","severity":1,"message":"396","line":486,"column":7,"nodeType":"397","messageId":"398","endLine":486,"endColumn":14,"suggestions":"444"},{"ruleId":"389","severity":1,"message":"417","line":3,"column":59,"nodeType":"391","messageId":"392","endLine":3,"endColumn":67},{"ruleId":"389","severity":1,"message":"418","line":3,"column":78,"nodeType":"391","messageId":"392","endLine":3,"endColumn":93},{"ruleId":"389","severity":1,"message":"445","line":4,"column":28,"nodeType":"391","messageId":"392","endLine":4,"endColumn":41},{"ruleId":"389","severity":1,"message":"415","line":1,"column":10,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"416","line":2,"column":8,"nodeType":"391","messageId":"392","endLine":2,"endColumn":13},{"ruleId":"389","severity":1,"message":"446","line":4,"column":10,"nodeType":"391","messageId":"392","endLine":4,"endColumn":17},{"ruleId":"389","severity":1,"message":"423","line":1,"column":10,"nodeType":"391","messageId":"392","endLine":1,"endColumn":37},{"ruleId":"389","severity":1,"message":"424","line":52,"column":23,"nodeType":"391","messageId":"392","endLine":52,"endColumn":32},{"ruleId":"389","severity":1,"message":"425","line":52,"column":34,"nodeType":"391","messageId":"392","endLine":52,"endColumn":43},{"ruleId":"389","severity":1,"message":"426","line":52,"column":45,"nodeType":"391","messageId":"392","endLine":52,"endColumn":58},{"ruleId":"389","severity":1,"message":"427","line":104,"column":27,"nodeType":"391","messageId":"392","endLine":104,"endColumn":37},{"ruleId":"389","severity":1,"message":"428","line":302,"column":43,"nodeType":"391","messageId":"392","endLine":302,"endColumn":53},{"ruleId":"389","severity":1,"message":"447","line":2,"column":10,"nodeType":"391","messageId":"392","endLine":2,"endColumn":26},{"ruleId":"389","severity":1,"message":"417","line":3,"column":57,"nodeType":"391","messageId":"392","endLine":3,"endColumn":65},{"ruleId":"389","severity":1,"message":"418","line":3,"column":76,"nodeType":"391","messageId":"392","endLine":3,"endColumn":91},{"ruleId":"389","severity":1,"message":"419","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"420","line":7,"column":10,"nodeType":"391","messageId":"392","endLine":7,"endColumn":14},{"ruleId":"389","severity":1,"message":"419","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"421","line":4,"column":10,"nodeType":"391","messageId":"392","endLine":4,"endColumn":22},{"ruleId":"389","severity":1,"message":"419","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":19},{"ruleId":"389","severity":1,"message":"421","line":9,"column":10,"nodeType":"391","messageId":"392","endLine":9,"endColumn":22},{"ruleId":"389","severity":1,"message":"422","line":21,"column":7,"nodeType":"391","messageId":"392","endLine":21,"endColumn":25},{"ruleId":"389","severity":1,"message":"393","line":1,"column":17,"nodeType":"391","messageId":"392","endLine":1,"endColumn":24},{"ruleId":"389","severity":1,"message":"429","line":5,"column":10,"nodeType":"391","messageId":"392","endLine":5,"endColumn":16},{"ruleId":"389","severity":1,"message":"446","line":26,"column":10,"nodeType":"391","messageId":"392","endLine":26,"endColumn":17},{"ruleId":"389","severity":1,"message":"394","line":68,"column":5,"nodeType":"391","messageId":"392","endLine":68,"endColumn":13},{"ruleId":"389","severity":1,"message":"448","line":87,"column":21,"nodeType":"391","messageId":"392","endLine":87,"endColumn":29},{"ruleId":"395","severity":1,"message":"396","line":248,"column":9,"nodeType":"397","messageId":"398","endLine":248,"endColumn":18,"suggestions":"449"},{"ruleId":"395","severity":1,"message":"396","line":309,"column":23,"nodeType":"397","messageId":"398","endLine":309,"endColumn":36,"suggestions":"450"},{"ruleId":"395","severity":1,"message":"396","line":315,"column":22,"nodeType":"397","messageId":"398","endLine":315,"endColumn":32,"suggestions":"451"},{"ruleId":"395","severity":1,"message":"396","line":316,"column":21,"nodeType":"397","messageId":"398","endLine":316,"endColumn":31,"suggestions":"452"},{"ruleId":"389","severity":1,"message":"453","line":380,"column":9,"nodeType":"391","messageId":"392","endLine":380,"endColumn":21},{"ruleId":"389","severity":1,"message":"411","line":404,"column":13,"nodeType":"391","messageId":"392","endLine":404,"endColumn":20},{"ruleId":"389","severity":1,"message":"412","line":404,"column":22,"nodeType":"391","messageId":"392","endLine":404,"endColumn":29},{"ruleId":"395","severity":1,"message":"396","line":426,"column":7,"nodeType":"397","messageId":"398","endLine":426,"endColumn":14,"suggestions":"454"},{"ruleId":"389","severity":1,"message":"455","line":486,"column":9,"nodeType":"391","messageId":"392","endLine":486,"endColumn":20},{"ruleId":"389","severity":1,"message":"456","line":487,"column":11,"nodeType":"391","messageId":"392","endLine":487,"endColumn":14},{"ruleId":"389","severity":1,"message":"457","line":66,"column":9,"nodeType":"391","messageId":"392","endLine":66,"endColumn":15},{"ruleId":"389","severity":1,"message":"458","line":52,"column":7,"nodeType":"391","messageId":"392","endLine":52,"endColumn":21},{"ruleId":"389","severity":1,"message":"459","line":53,"column":9,"nodeType":"391","messageId":"392","endLine":53,"endColumn":21},"@typescript-eslint/no-unused-vars","'Ref' is defined but never used.","Identifier","unusedVar","'useMemo' is defined but never used.","'setColor' is assigned a value but never used.","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull",["460"],["461"],["462"],["463"],["464"],["465"],"'deltaX' is assigned a value but never used.",["466"],"'canvasWidth' is assigned a value but never used.","'canvasHeight' is assigned a value but never used.",["467"],["468"],"'clientX' is assigned a value but never used.","'clientY' is assigned a value but never used.",["469"],["470"],"'ColorType' is defined but never used.","'Color' is defined but never used.","'hexToRgb' is defined but never used.","'updateImageData' is defined but never used.","'FC' is defined but never used.","'Tool' is defined but never used.","'DownOutlined' is defined but never used.","'activeColorTypeCls' is assigned a value but never used.","'numberLiteralTypeAnnotation' is defined but never used.","'x' is defined but never used.","'y' is defined but never used.","'arr' is defined but never used.","'fontFamily' is assigned a value but never used.","'lineHeight' is assigned a value but never used.","'Button' is defined but never used.","'canvas' is defined but never used.","'showPixel' is assigned a value but never used.","'getPixelColorOnPixelBoxs' is defined but never used.",["471"],"'toolShape' is defined but never used.",["472"],["473"],["474"],["475"],["476"],["477"],["478"],["479"],["480"],["481"],"'isPointInPath' is defined but never used.","'refresh' is defined but never used.","'drawColorToPixel' is defined but never used.","'setScale' is assigned a value but never used.",["482"],["483"],["484"],["485"],"'onMousewheel' is assigned a value but never used.",["486"],"'handleClick' is assigned a value but never used.","'dpr' is assigned a value but never used.","'points' is assigned a value but never used.","'mainPixel' is defined but never used.","'size' is assigned a value but never used.",{"messageId":"487","fix":"488","desc":"489"},{"messageId":"487","fix":"490","desc":"489"},{"messageId":"487","fix":"491","desc":"489"},{"messageId":"487","fix":"492","desc":"489"},{"messageId":"487","fix":"493","desc":"489"},{"messageId":"487","fix":"494","desc":"489"},{"messageId":"487","fix":"495","desc":"489"},{"messageId":"487","fix":"496","desc":"489"},{"messageId":"487","fix":"497","desc":"489"},{"messageId":"487","fix":"498","desc":"489"},{"messageId":"487","fix":"499","desc":"489"},{"messageId":"487","fix":"500","desc":"489"},{"messageId":"487","fix":"501","desc":"489"},{"messageId":"487","fix":"502","desc":"489"},{"messageId":"487","fix":"503","desc":"489"},{"messageId":"487","fix":"504","desc":"489"},{"messageId":"487","fix":"505","desc":"489"},{"messageId":"487","fix":"506","desc":"489"},{"messageId":"487","fix":"507","desc":"489"},{"messageId":"487","fix":"508","desc":"489"},{"messageId":"487","fix":"509","desc":"489"},{"messageId":"487","fix":"510","desc":"489"},{"messageId":"487","fix":"511","desc":"489"},{"messageId":"487","fix":"512","desc":"489"},{"messageId":"487","fix":"513","desc":"489"},{"messageId":"487","fix":"514","desc":"489"},{"messageId":"487","fix":"515","desc":"489"},"suggestOptionalChain",{"range":"516","text":"517"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"518","text":"517"},{"range":"519","text":"517"},{"range":"520","text":"517"},{"range":"521","text":"517"},{"range":"522","text":"517"},{"range":"523","text":"517"},{"range":"524","text":"517"},{"range":"525","text":"517"},{"range":"526","text":"517"},{"range":"527","text":"517"},{"range":"528","text":"517"},{"range":"529","text":"517"},{"range":"530","text":"517"},{"range":"531","text":"517"},{"range":"532","text":"517"},{"range":"533","text":"517"},{"range":"534","text":"517"},{"range":"535","text":"517"},{"range":"536","text":"517"},{"range":"537","text":"517"},{"range":"538","text":"517"},{"range":"539","text":"517"},{"range":"540","text":"517"},{"range":"541","text":"517"},{"range":"542","text":"517"},{"range":"543","text":"517"},[6644,6645],"?",[6817,6818],[7936,7937],[8175,8176],[8220,8221],[10763,10764],[10884,10885],[10983,10984],[11951,11952],[13309,13310],[262,263],[323,324],[6644,6645],[6817,6818],[7936,7937],[8175,8176],[8220,8221],[10763,10764],[10884,10885],[10983,10984],[11951,11952],[13309,13310],[6879,6880],[8851,8852],[9069,9070],[9114,9115],[12056,12057]]